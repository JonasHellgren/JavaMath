<passage file_path=/src/main/java/plotting/ScatterChart.java>
package plotting;

import common.RandUtils;
import org.knowm.xchart.SwingWrapper;
import org.knowm.xchart.XYChart;
import org.knowm.xchart.XYChartBuilder;
import org.knowm.xchart.XYSeries;
import org.knowm.xchart.style.Styler;

import java.util.LinkedList;
import java.util.List;

public class ScatterChart {

</passage>
<passage file_path=/src/main/java/plotting/HeatMapChartPlotterInt.java>
public class HeatMapChartPlotterInt {

    public static void main(String[] args) {
        int[][] data = getData();
        int[][] dataRot=transposeMatrix(data);
        HeatMapChart chart = createChart();
        addData(chart, dataRot);
        addCellText(chart, data);
        new SwingWrapper<>(chart).displayChart();
    }

    private static int[][] getData() {
        return new int[][]{
                {0, 1, 50, 100,10},  //(0,0), (1,0),...
                {2, 3, 5, 3,10},
                {2, 4, 3, 2,10},
                {30, 2, 4, 3,10}   //x(0,3), x(1,3),...
        };
    }

    @NotNull

</passage>
<passage file_path=/src/test/java/optimization_apache/TestCircleFitting.java>
    }

}

</passage>
<passage file_path=/src/test/java/optimization_apache/TestCircleFitting.java>
    @Test
    public void testCircleFitting2() {

        //x = circle center = (px,py)
        CircleScalar circle = new CircleScalar();
        circle.addPoint(30.0, 68.0);
        circle.addPoint(50.0, -6.0);
        circle.addPoint(110.0, -20.0);
        circle.addPoint(35.0, 15.0);
        circle.addPoint(45.0, 97.0);
        MultivariateOptimizer optimizer=TestHelper.getConjugateGradientOptimizer(REL_TRES_HOLD, ABS_TRES_HOLD);
        PointValuePair optimum = TestHelper.gradientOptimize(
                optimizer,circle.getObjectiveFunction(),circle.getObjectiveFunctionGradient(),
                INITIAL_GUESS, NOF_EVAL_MAX);

        TestHelper.printPointValuePair(optimum);
        TestHelper.printOptimizerStats(optimizer);

        Vector2D center = new Vector2D(optimum.getPointRef()[0], optimum.getPointRef()[1]);
        Assert.assertEquals(69.960161753, circle.getRadius(center), DELTA);
        Assert.assertEquals(96.075902096, center.getX(), DELTA);
        Assert.assertEquals(48.135167894, center.getY(), DELTA);
    }

</passage>
<passage file_path=/src/main/java/plotting/DataGenerator.java>
package plotting;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;

public class DataGenerator {

    /**
     * Generates a set of random walk data
     *
     * @param numPoints
     * @return
     */
    public static double[] getRandomWalk(int numPoints) {

        double[] y = new double[numPoints];
        y[0] = 0;
        for (int i = 1; i < y.length; i++) {
            y[i] = y[i - 1] + Math.random() - .5;
        }
        return y;
    }

    public static List<Double> getGaussianData(int count) {

        List<Double> data = new ArrayList<>(count);
        Random r = new Random();
        for (int i = 0; i < count; i++) {
            data.add(r.nextGaussian() * 10);
        }
        return data;
    }

}

</passage>
<passage file_path=/src/test/java/optimization_apache/TestBowlOptimizationNelderMeadSimplex.java>
    }
}

</passage>
<passage file_path=/src/main/java/apache_common/info.md>
org.apache.commons.math4.optim - function maximization or minimization
org.apache.commons.math4.ode - Ordinary Differential Equations integration
org.apache.commons.math4.genetics - Genetic Algorithms
org.apache.commons.math4.fitting - Curve Fitting
org.apache.commons.math4.ml - Machine Learning
</passage>
<passage file_path=/src/main/java/plotting/ScatterChart.java>
public class ScatterChart {

    public static void main(String[] args) {

        XYChart chart = getChart();
        new SwingWrapper<>(chart).displayChart();
    }

    public static XYChart getChart() {

        // Create Chart
        XYChart chart = new XYChartBuilder().width(400).height(300).build();

        // Customize Chart
        chart.getStyler().setDefaultSeriesRenderStyle(XYSeries.XYSeriesRenderStyle.Scatter);
        chart.getStyler().setChartTitleVisible(false);
        chart.getStyler().setLegendPosition(Styler.LegendPosition.InsideSW);
        chart.getStyler().setMarkerSize(5);

        // Series
        List<Double> xData = new LinkedList<>();
        List<Double> yData = new LinkedList<>();
        int size = 100;
        for (int i = 0; i < size; i++) {
            xData.add(RandUtils.getRandomDouble(-10,10));
            yData.add(RandUtils.getRandomDouble(-10,10));

        }
        chart.addSeries("Scatter", xData, yData);

        return chart;
    }


}

</passage>
<passage file_path=/src/main/java/plotting/SwingShowHeatMap.java>
        for (int row = 0; row < data.length; row++) {
            for (int col = 0; col < data[row].length; col++) {
                double value = data[row][col];
                Color color = calculateColor(value, min, max);
                g2d.setColor(color);
                // Invert y-axis for cell drawing
                int x = col * cellWidth + margin;
                int y = (data.length - 1 - row) * cellHeight;
                g2d.fillRect(x, y, cellWidth, cellHeight);

                // Draw value in cell
                g2d.setColor(Color.BLACK);
                String text = String.format("%.1f", value);
                FontMetrics metrics = g2d.getFontMetrics();
                int textX = x + (cellWidth - metrics.stringWidth(text)) / 2;
                int textY = y + ((cellHeight - metrics.getHeight()) / 2) + metrics.getAscent();
                g2d.drawString(text, textX, textY);
            }
        }
    }

</passage>
<passage file_path=/src/main/java/plotting/HeatMapChartPlotterDouble.java>
package plotting;


    public class HeatMapChartPlotterDouble {

        public static void main(String[] args) {
            double[][] data = {
                    {1.0, 2.0, 3.0},
                    {2.0, 3.0, 4.0},
                    {5.0, 4.0, 5.0}
            };


            var shower=SwingShowHeatMap.builder()
                 //   .xLabels(new String[]{"X1", "X2", "X3"})
              //      .yLabels(new String[]{"Y1", "Y2", "Y3"})
                    .isLabels(false)
                    .build();

            shower.showMap(data,"map");
        }



    }

</passage>
<passage file_path=/src/test/java/optimization_apache/TestHelper.java>
public class TestHelper {

    static void printPointValuePair(PointValuePair optimum) {
        System.out.println("found opt point = " + Arrays.toString(optimum.getPointRef())+", value = "+optimum.getValue());
    }

    static void printOptimizerStats(MultivariateOptimizer optimizer) {
        System.out.println("optimizer.getEvaluations() = " + optimizer.getEvaluations());
        System.out.println("optimizer.getIterations() = " + optimizer.getIterations());
    }

    static MultivariateOptimizer getConjugateGradientOptimizer(double relTresHold, double absTresHold) {
        return new NonLinearConjugateGradientOptimizer(
                NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE,
                new SimpleValueChecker(relTresHold, absTresHold));
    }

    static PointValuePair gradientOptimize(MultivariateOptimizer optimizer,

</passage>
<passage file_path=/src/test/java/optimization_apache/TestCircleFitting.java>
package optimization_apache;

import optimization_apache.models.CircleScalar;
import org.apache.commons.math3.geometry.euclidean.twod.Vector2D;
import org.apache.commons.math3.optim.PointValuePair;
import org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer;
import org.junit.Assert;
import org.junit.Test;

/**
 * Thew objective is to fit circle center to given points on circle diameter
 */

public class TestCircleFitting {

</passage>
<passage file_path=/src/main/java/plotting/SwingShowHeatMap.java>
    }

    private  Color calculateColor(double value, double min, double max) {
        double ratio = (value - min) / (max - min);
        int r= MathUtils.clip((int) (ratio*255)+ MIN_DARKNESS,0,255);
        return new Color(r,r,r);
    }

    private void displayImage(BufferedImage image) {
        SwingUtilities.invokeLater(() -> {
            ImageIcon icon = new ImageIcon(image);
            JFrame frame = new JFrame();
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.setLayout(new BorderLayout());
            frame.add(new JLabel(icon), BorderLayout.CENTER);
            frame.pack();
            frame.setLocationRelativeTo(null);
            frame.setVisible(true);
        });
    }

}

</passage>
<passage file_path=/src/main/java/apache_common/info.md>
https://commons.apache.org/proper/commons-math/userguide/overview.html

org.apache.commons.math4.stat - statistics, statistical tests
org.apache.commons.math4.analysis - rootfinding, integration, interpolation, polynomials
org.apache.commons.math4.random - random numbers, strings and data generation
org.apache.commons.math4.special - special functions (Gamma, Beta)
org.apache.commons.math4.linear - matrices, solving linear systems
org.apache.commons.math4.util - common math/stat functions extending java.lang.Math
org.apache.commons.math4.complex - complex numbers
org.apache.commons.math4.distribution - probability distributions
org.apache.commons.math4.fraction - rational numbers
org.apache.commons.math4.transform - transform methods (Fast Fourier)
org.apache.commons.math4.geometry - geometry (Euclidean spaces and Binary Space Partitioning)
org.apache.commons.math4.optim - function maximization or minimization
org.apache.commons.math4.ode - Ordinary Differential Equations integration
</passage>
<passage file_path=/src/main/java/plotting/SwingShowHeatMap.java>
package plotting;

import common.MathUtils;
import lombok.Builder;

import javax.swing.*;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.Arrays;
import java.util.stream.IntStream;

@Builder

</passage>
<passage file_path=/src/main/java/plotting/HeatMapChartPlotterInt.java>
    @NotNull
    private static org.knowm.xchart.HeatMapChart createChart() {
        var chart = new HeatMapChartBuilder()
                .title("Sample HeatMap")
                .xAxisTitle("X Axis")
                .yAxisTitle("Y Axis")
                .width(300).height(300)
                .build();
        chart.getStyler().setChartTitleVisible(true).setLegendVisible(false);
        chart.getStyler().setMin(0).setMax(100).setRangeColors(new Color[]{Color.LIGHT_GRAY,Color.WHITE});
        chart.getStyler().setAnnotationTextFontColor(Color.BLACK);
        chart.getStyler().setAnnotationTextFont(new Font("Arial", Font.BOLD, 22));
        return chart;
    }

    private static void addData(HeatMapChart chart, int[][] data) {
        int[] xData = IntStream.rangeClosed(0, 4).toArray();
        int[] yData=IntStream.rangeClosed(0, 3).toArray();
        chart.addSeries("a", xData, yData, data);
    }

    private static void addCellText(org.knowm.xchart.HeatMapChart chart, int[][] data) {

</passage>
<passage file_path=/src/main/java/plotting/HeatMapChartPlotterInt.java>
package plotting;

import org.jetbrains.annotations.NotNull;
import org.knowm.xchart.AnnotationText;
import org.knowm.xchart.HeatMapChart;
import org.knowm.xchart.HeatMapChartBuilder;

import org.knowm.xchart.SwingWrapper;
import java.awt.*;
import java.util.stream.IntStream;

public class HeatMapChartPlotterInt {

</passage>
<passage file_path=/src/test/java/optimization_apache/TestDepotApacheOptimizers.java>
    @Before
    public void init() {
        model= DepotModel.builder()
                .kList(new double[]{1,2,3})
                .pMaxList(new double[]{0.5,0.5,0.5})
                .socList(new double[]{1,1,1})
                .pDepotMax(1)
                .barrierWeight(BARRIER_WEIGHT)
                .barrierWeightQuad(BARRIER_WEIGHT)
                .socMax(1)
                .build();

        optimizerMv=new NonLinearConjugateGradientOptimizer(
                NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE,
                new SimpleValueChecker(REL_TRES_HOLD,ABS_TRES_HOLD));

        optimizerCm=new CMAESOptimizer(

</passage>
<passage file_path=/src/test/java/joptimizer/TestSquaredBracketsModel.java>
@Log
class TestSquaredBracketsModel {

    SquaredBracketsModel model;
    ConvexMultivariateRealFunction objectiveFunction;

    @BeforeEach
    void init() {
        model=new SquaredBracketsModel();

        objectiveFunction = new ConvexMultivariateRealFunction() {
            @Override
            public double value(DoubleMatrix1D dm) {
                return model.calculateObjectiveValue(dm.toArray());
            }

            @Override
            public DoubleMatrix1D gradient(DoubleMatrix1D dm) {
                return  new DenseDoubleMatrix1D(model.calculateObjectiveGradient(dm.toArray()));
            }

            @Override
            public DoubleMatrix2D hessian(DoubleMatrix1D doubleMatrix1D) {
                DoubleFactory2D F2 = DoubleFactory2D.dense;
                return F2.make(new double[][] {
                        { 0.0, 0.0},
                        { 0.0, 0}});
            }

            @Override
            public int getDim() {
                return 2;        }
        };

    }


    @SneakyThrows

</passage>
<passage file_path=/src/test/java/joptimizer/Test3DimQP.java>
    }

}

</passage>
<passage file_path=/src/test/java/apache_common/FilterTest.java>
        RealMatrix P0 = new Array2DRowRealMatrix(new double[][] { { 1, 1 }, { 1, 1 } });
// R = [ measurementNoise^2 ]
        RealMatrix R = new Array2DRowRealMatrix(new double[] { Math.pow(measurementNoise, 2) });

// constant control input, increase velocity by 0.1 m/s per cycle
        RealVector u = new ArrayRealVector(new double[] { 0.1d });

        ProcessModel pm = new DefaultProcessModel(A, B, Q, x, P0);
        MeasurementModel mm = new DefaultMeasurementModel(H, R);
        KalmanFilter filter = new KalmanFilter(pm, mm);

        RandomGenerator rand = new JDKRandomGenerator();

        RealVector tmpPNoise = new ArrayRealVector(new double[] { Math.pow(dt, 2d) / 2d, dt });
        RealVector mNoise = new ArrayRealVector(1);

// iterate 60 steps
        for (int i = 0; i < 60; i++) {

</passage>
<passage file_path=/src/test/java/optimization_apache/TestConstrainedRosenbrock.java>
    private static PointValuePair calcOptimum(PointValuePair bestOptimum, PointValuePair optimum) {
        if (optimum.getValue()< bestOptimum.getValue()) {
            bestOptimum = optimum;
            System.out.println("New best found");
            TestHelper.printPointValuePair(bestOptimum);
        }
        return bestOptimum;  //keep old if new is not better
    }

    private PointValuePair getResultsFromRandomInitPoint(MultivariateOptimizer optimizer, ConstrainedRosenbrock model) {
        double[] initialGuess = new double[]{getSingleRandom(), getSingleRandom()};
        return TestHelper.gradientOptimize(optimizer,
                model.getObjectiveFunction(),model.getFiniteDiffGradient(),initialGuess, NOF_EVAL_MAX);
    }

    private static double getSingleRandom() {
        return RandUtils.getRandomDouble(ConstrainedRosenbrock.LB, ConstrainedRosenbrock.UB);
    }

}

</passage>
<passage file_path=/src/main/java/plotting/TradingChartsExample.java>
package plotting;

import org.apache.commons.math3.util.Pair;
import org.knowm.xchart.*;
import org.knowm.xchart.style.markers.SeriesMarkers;
import java.util.ArrayList;
import java.util.List;

public class TradingChartsExample {

</passage>
<passage file_path=/src/test/java/joptimizer/Test3DimQP.java>
package joptimizer;

import cern.colt.matrix.DoubleMatrix1D;
import cern.colt.matrix.DoubleMatrix2D;
import cern.colt.matrix.impl.DenseDoubleMatrix1D;
import cern.colt.matrix.impl.DenseDoubleMatrix2D;
import com.joptimizer.functions.ConvexMultivariateRealFunction;
import com.joptimizer.optimizers.JOptimizer;
import com.joptimizer.optimizers.OptimizationRequest;
import com.joptimizer.optimizers.OptimizationResponse;
import lombok.SneakyThrows;
import lombok.extern.java.Log;
import org.apache.commons.lang3.ArrayUtils;

import static org.junit.jupiter.api.Assertions.assertEquals;

@Log

</passage>
<passage file_path=/src/test/java/joptimizer/Test3DimQP.java>
        };



        //optimization problem
        OptimizationRequest or = new OptimizationRequest();
        or.setF0(objectiveFunction);
        //or.setInitialPoint(new double[] {0.5,0.5,94375.0});
        or.setInitialPoint(new double[]{-2, -2, 10});
        or.setFi(inequalities);
        or.setCheckKKTSolutionAccuracy(true);

        //optimization
        JOptimizer opt = new JOptimizer();
        opt.setOptimizationRequest(or);
        opt.optimize();


        OptimizationResponse response = opt.getOptimizationResponse();
        double[] sol = response.getSolution();
        log.info("sol   : " + ArrayUtils.toString(sol));
        log.info("value : " + objectiveFunction.value(new DenseDoubleMatrix1D(sol)));
        assertEquals(-2., sol[0], TOL);
        assertEquals(-2., sol[1], TOL);
        assertEquals(-1.75, sol[2], TOL);
    }

</passage>
<passage file_path=/src/test/java/optimization_apache/TestDepotApacheOptimizers.java>
        optimizerCm=new CMAESOptimizer(
                MAX_ITERATIONS, // Max iterations
                1e-6, // Stop fitness (tolerance for considering a solution good enough)
                true, // Whether to generate diagnostics
                1, // Check period
                1, // Random seed for reproducibility, use any integer for deterministic results
                new JDKRandomGenerator(),
                false,
                new SimpleValueChecker(REL_TRES_HOLD,ABS_TRES_HOLD)
        );

        optimizerSm=new SimplexOptimizer(REL_TRES_HOLD,ABS_TRES_HOLD);

    }

</passage>
<passage file_path=/pom.xml>
<dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-math3</artifactId>
            <version>3.6.1</version>
        </dependency>

        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
            <version>3.12.0</version>
        </dependency>
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter</artifactId>
            <version>RELEASE</version>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>com.google.guava</groupId>
            <artifactId>guava</artifactId>
            <version>32.0.1-jre</version>
        </dependency>

        <dependency>
            <groupId>org.knowm.xchart</groupId>
            <artifactId>xchart</artifactId>
            <version>3.8.6</version>
        </dependency>
</passage>
<passage file_path=/src/test/java/optimization_apache/TestBowlOptimizationNelderMeadSimplex.java>
package optimization_apache;

import org.apache.commons.math3.geometry.euclidean.twod.Vector2D;
import org.apache.commons.math3.optim.InitialGuess;
import org.apache.commons.math3.optim.MaxEval;
import org.apache.commons.math3.optim.PointValuePair;
import org.apache.commons.math3.optim.nonlinear.scalar.GoalType;
import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction;
import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.NelderMeadSimplex;
import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer;
import org.junit.Assert;
import org.junit.Test;

/**
 * Gradient free
 *
 * In this example, we define the objective function using the MultivariateFunction interface. The gradient is not
 * explicitly provided. The SimplexOptimizer will approximate the gradient using numerical finite
 * differences.
 *
 */

public class TestBowlOptimizationNelderMeadSimplex {

</passage>
<passage file_path=/src/test/java/optimization_apache/TestHelper.java>
package optimization_apache;

import org.apache.commons.math3.optim.InitialGuess;
import org.apache.commons.math3.optim.MaxEval;
import org.apache.commons.math3.optim.PointValuePair;
import org.apache.commons.math3.optim.SimpleValueChecker;
import org.apache.commons.math3.optim.nonlinear.scalar.GoalType;
import org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer;
import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction;
import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunctionGradient;
import org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer;

import java.util.Arrays;

public class TestHelper {

</passage>
<passage file_path=/src/main/java/optimization_apache/interfaces_adapter/OptimizeAdapter.java>
package optimization_apache.interfaces_adapter;

import optimization_apache.helpers.FiniteDiffGradientCalculator;
import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction;
import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunctionGradient;

public class OptimizeAdapter implements AdapterInterface {

    OptimizationModelInterface optModel;
    FiniteDiffGradientCalculator gradient;

    public OptimizeAdapter(OptimizationModelInterface optModel) {
        this.optModel = optModel;
        this.gradient = new FiniteDiffGradientCalculator(getObjectiveFunction(), optModel.getEps());
    }

    @Override
    public ObjectiveFunction getObjectiveFunction() {
        return new ObjectiveFunction(point ->
                optModel.getObjective(point) + optModel.getPenalty(point));
    }

    @Override
    public ObjectiveFunctionGradient getGradient() {
        return gradient.getFiniteDiffGradient();
    }

}

</passage>
<passage file_path=/src/test/java/joptimizer/Test2DimQP.java>
    }



}

</passage>
<passage file_path=/src/test/java/optimization_apache/TestSumOfThreeUsingAdapter.java>
    @Test
    public void givenAdapter_thenCorrectOptimum() {
        MultivariateOptimizer optimizer =
                TestHelper.getConjugateGradientOptimizer(RELATIVE_THRESHOLD, ABSOLUTE_THRESHOLD);
        OptimizationModelInterface model = new SumOfThreeModel(PEN_COEFF, EPS);
        AdapterInterface adapter = new OptimizeAdapter(model);
        PointValuePair optimum = TestHelper.gradientOptimize(
                optimizer, adapter.getObjectiveFunction(), adapter.getGradient(),
                initialGuess, NOF_EVAL_MAX);

        TestHelper.printPointValuePair(optimum);

        TestHelper.printOptimizerStats(optimizer);
        Assert.assertArrayEquals(OPT_POINT, optimum.getPointRef(), DELTA);
    }
}

</passage>
<passage file_path=/src/test/java/optimization_apache/TestDepotApacheOptimizers.java>
package optimization_apache;

import optimization_apache.depot_charging.DepotModel;
import org.apache.commons.math3.optim.*;
import org.apache.commons.math3.optim.nonlinear.scalar.GoalType;
import org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer;
import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction;
import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunctionGradient;
import org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer;
import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer;
import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.NelderMeadSimplex;
import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer;
import org.apache.commons.math3.random.JDKRandomGenerator;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

import java.util.Arrays;

public class TestDepotApacheOptimizers {

</passage>
<passage file_path=/pom.xml>
<dependency>
            <groupId>org.knowm.xchart</groupId>
            <artifactId>xchart</artifactId>
            <version>3.8.6</version>
        </dependency>

        <dependency>
            <groupId>jfree</groupId>
            <artifactId>jfreechart</artifactId>
            <version>1.0.13</version>
        </dependency>

        <dependency>
            <groupId>com.joptimizer</groupId>
            <artifactId>joptimizer</artifactId>
            <version>5.0.0</version>
        </dependency>



    </dependencies>

</project>
</passage>
<passage file_path=/src/test/java/common/TestIndexFinder.java>
public class TestIndexFinder {

    int[] arrayInt;
    double[] arrayDouble;


    @BeforeEach
    public void init() {
        arrayInt = new int[]{0, 1, 2, 3, 4, 5, 6, 7};
        arrayDouble = new double[]{0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0};

    }

    @Test
    public void givenIntNumber_thenCorrectIndex() {
        Assertions.assertEquals(0,IndexFinder.findIndex(arrayInt,0));
        Assertions.assertEquals(4, IndexFinder.findIndex(arrayInt, 4));
        Assertions.assertEquals(7, IndexFinder.findIndex(arrayInt, 7));
        Assertions.assertEquals(-1, IndexFinder.findIndex(arrayInt, -7));
    }

    @Test
    public void givenDoubleNumber_thenCorrectIndex() {
        Assertions.assertEquals(0,IndexFinder.findBucket(arrayDouble,0.5));
        Assertions.assertEquals(4, IndexFinder.findBucket(arrayDouble, 4.2));
        Assertions.assertEquals(7, IndexFinder.findBucket(arrayDouble, 42));
        Assertions.assertEquals(-1, IndexFinder.findBucket(arrayDouble, -7));
    }

}

</passage>
<passage file_path=/src/main/java/common/IndexFinder.java>
package common;

import lombok.extern.java.Log;

import java.util.Arrays;

@Log
public class IndexFinder {

    public static int findIndex(int[] arr, int t)
    {
        int index = Arrays.binarySearch(arr, t);

        System.out.println("index = " + index);
        return (index < 0) ? -1 : index;
    }

    public static int findBucket(double[] array, double value) {

        if (value <array[0]) {
            log.warning("value below first bucket");
            return -1;
        }

        for (int i = 0; i < array.length-1; i++) {
            if (value < array[i+1]) {
                return i;  // Value falls into bucket i
            }
        }

        log.warning("Value exceeds the last bucket");
        return array.length-1;
    }

}

</passage>
<passage file_path=/src/main/java/plotting/BarChartOverlapped.java>
public class BarChartOverlapped {

    public static void main(String[] args) {

        CategoryChart chart = new CategoryChartBuilder()
                .width(800).height(600).title("Score Histogram").xAxisTitle("Score").yAxisTitle("Number").build();
        // Customize Chart
        chart.getStyler().setLegendPosition(Styler.LegendPosition.InsideNW);
        chart.getStyler().setAvailableSpaceFill(.96);
        chart.getStyler().setOverlapped(true);

        // Series
        Histogram histogram1 = new Histogram(DataGenerator.getGaussianData(10000), 20, -20, 20);
        Histogram histogram2 = new Histogram(DataGenerator.getGaussianData(5000), 20, -20, 20);

        chart.addSeries("histogram 1", histogram1.getxAxisData(), histogram1.getyAxisData());
        chart.addSeries("histogram 2", histogram2.getxAxisData(), histogram2.getyAxisData());


        new SwingWrapper<>(chart).displayChart();
    }
}

</passage>
<passage file_path=/src/test/java/apache_common/StatisticsTest.java>
public class StatisticsTest {


    public static final double DELTA = 0.01;
    public static final List<Double> VALUES = List.of(1d, 2d, 3d, 4d);

    @Test
    public void whenRegression_thenCorrect() {
        double[][] data = { { 1, 3 }, {2, 5 }, {3, 7 }, {4, 14 }, {5, 11 }};
        SimpleRegression regression = new SimpleRegression();
        regression.addData(data);
        System.out.println("regression.getSlope() = " + regression.getSlope());
        assertEquals(2.5,regression.getSlope(), DELTA);
    }

    /**
     * DescriptiveStatistics maintains the input data in memory and has the capability of producing "rolling" statistics computed from a "window" consisting of the most recently added values.
     *
     * SummaryStatistics does not store the input data values in memory, so the statistics included in this aggregate are limited to those that can be computed in one pass through the data without access to the full array of values.
     */

    @Test

</passage>
<passage file_path=/src/main/java/plotting/PieChart.java>
package plotting;
import org.knowm.xchart.PieChartBuilder;
import org.knowm.xchart.SwingWrapper;


public class PieChart  {

    public static void main(String[] args) {
        var chart = new PieChartBuilder().width(800).height(600).title("Sample Pie Chart").build();
        chart.addSeries("Gold", 40);
        chart.addSeries("Silver", 30);
        chart.addSeries("Platinum", 20);
        chart.addSeries("Copper", 10);
        new SwingWrapper<>(chart).displayChart();
    }


}

</passage>
<passage file_path=/src/main/java/optimization_apache/interfaces_adapter/AdapterInterface.java>
package optimization_apache.interfaces_adapter;

import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction;
import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunctionGradient;

public interface AdapterInterface {
    ObjectiveFunction getObjectiveFunction();
    ObjectiveFunctionGradient getGradient();
}

</passage>
<passage file_path=/src/test/java/optimization_apache/TestBowlOptimizationNelderMeadSimplex.java>
        PointValuePair result = optimizer.optimize(
                new MaxEval(1000),                    // Maximum number of evaluations
                objective,                           // Objective function
                GoalType.MINIMIZE,                   // Minimization problem
                new NelderMeadSimplex(initialGuess.length, simplexSize),   // Nelder-Mead simplex
                new InitialGuess(initialGuess));

        Vector2D point = new Vector2D(result.getPointRef()[0], result.getPointRef()[1]);
        System.out.println("point = " + point);
        Assert.assertEquals(0, point.getX(), DELTA);
        Assert.assertEquals(0, point.getY(), DELTA);
    }

</passage>
<passage file_path=/src/test/java/optimization_apache/TestHelper.java>
    static PointValuePair gradientOptimize(MultivariateOptimizer optimizer,
                                           ObjectiveFunction objFunction,
                                           ObjectiveFunctionGradient gradientFunction,
                                           double[] initialGuess, int nofEvalMax) {
        return optimizer.optimize(new MaxEval(nofEvalMax),
                objFunction, gradientFunction,
                GoalType.MINIMIZE,
                new InitialGuess(initialGuess));
    }

}

</passage>
<passage file_path=/src/main/java/plotting/LinesInSubPlots.java>
package plotting;

import org.knowm.xchart.SwingWrapper;
import org.knowm.xchart.XYChart;
import org.knowm.xchart.XYChartBuilder;
import org.knowm.xchart.XYSeries;
import org.knowm.xchart.style.markers.SeriesMarkers;

import java.util.ArrayList;
import java.util.List;

public class LinesInSubPlots {

    public static void main(String[] args) {
        int numCharts = 4;
        List<XYChart> charts = new ArrayList<>();

        for (int i = 0; i < numCharts; i++) {
            XYChart chart = new XYChartBuilder().xAxisTitle("X").yAxisTitle("Y").width(600).height(400).build();
            chart.getStyler().setYAxisMin(-10d);
            chart.getStyler().setYAxisMax(10d);
            XYSeries series = chart.addSeries("" + i, null, DataGenerator.getRandomWalk(200));
            series.setMarker(SeriesMarkers.NONE);
            charts.add(chart);
        }
        new SwingWrapper<>(charts).displayChartMatrix();
    }

}

</passage>
<passage file_path=/src/test/java/optimization_apache/TestBowlOptimizationNonLinearConjugateGradient.java>
package optimization_apache;


import optimization_apache.models.Bowl;
import org.apache.commons.math3.geometry.euclidean.twod.Vector2D;
import org.apache.commons.math3.optim.PointValuePair;
import org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer;
import org.junit.Assert;
import org.junit.Test;

public class TestBowlOptimizationNonLinearConjugateGradient {

</passage>
<passage file_path=/src/test/java/apache_common/StatisticsTest.java>
    @Test
    public void whenDescriptiveStatisticsWindow2_thenCorrect() {
        DescriptiveStatistics ds=new DescriptiveStatistics();
        ds.setWindowSize(2);
        addValues(ds, VALUES);

        System.out.println("ds.getMean() = " + ds.getMean());
        System.out.println("ds.getStandardDeviation() = " + ds.getStandardDeviation());
        System.out.println("ds.getPercentile(0.9) = " + ds.getPercentile(0.9));

        assertEquals(3.5,ds.getMean(),DELTA);

    }

}

</passage>
<passage file_path=/src/main/java/plotting/BarChart.java>
package plotting;

import org.knowm.xchart.CategoryChart;
import org.knowm.xchart.CategoryChartBuilder;
import org.knowm.xchart.SwingWrapper;
import org.knowm.xchart.style.Styler;

import java.util.List;

public class BarChart {

    public static void main(String[] args) {
        CategoryChart chart = new CategoryChartBuilder()
                .width(800).height(600).title("Score Histogram").xAxisTitle("Score").yAxisTitle("Number").build();
        chart.getStyler().setLegendPosition(Styler.LegendPosition.InsideNW);
        chart.addSeries("test 1", List.of(0, 1, 2, 3, 4), List.of(4, 5, 9, 6, 5) );
        new SwingWrapper<>(chart).displayChart();
    }

}

</passage>
<passage file_path=/src/test/java/apache_common/FilterTest.java>
        for (int i = 0; i < 60; i++) {
            filter.predict(u);

            // simulate the process
            RealVector pNoise = tmpPNoise.mapMultiply(accelNoise * rand.nextGaussian());

            // x = A * x + B * u + pNoise
            x = A.operate(x).add(B.operate(u)).add(pNoise);

            // simulate the measurement
            mNoise.setEntry(0, measurementNoise * rand.nextGaussian());

            // z = H * x + m_noise
            RealVector z = H.operate(x).add(mNoise);

            filter.correct(z);

            double position = filter.getStateEstimation()[0];
            double velocity = filter.getStateEstimation()[1];
            System.out.println("position = " + position);
        }
    }

</passage>
<passage file_path=/src/main/java/optimization_apache/helpers/FiniteDiffGradientCalculator.java>
        });
    }

}

</passage>
<passage file_path=/src/test/java/apache_common/StatisticsTest.java>
    @Test
    public void whenDescriptiveStatistics_thenCorrect() {
        DescriptiveStatistics ds=new DescriptiveStatistics();
        addValues(ds, VALUES);

        System.out.println("ds.getMean() = " + ds.getMean());
        System.out.println("ds.getStandardDeviation() = " + ds.getStandardDeviation());
        System.out.println("p10 = " + ds.getPercentile(10));
        System.out.println("p90 = " + ds.getPercentile(90));

        assertEquals(2.5,ds.getMean(),DELTA);


    }

    private static void addValues(DescriptiveStatistics ds, List<Double> values) {
        values.forEach(ds::addValue);
    }

    @Test

</passage>
<passage file_path=/src/test/java/joptimizer/TestSquaredBracketsModel.java>
package joptimizer;

import cern.colt.matrix.DoubleFactory2D;
import cern.colt.matrix.DoubleMatrix1D;
import cern.colt.matrix.DoubleMatrix2D;
import cern.colt.matrix.impl.DenseDoubleMatrix1D;
import com.joptimizer.functions.ConvexMultivariateRealFunction;
import com.joptimizer.optimizers.NewtonLEConstrainedFSP;
import com.joptimizer.optimizers.OptimizationRequest;
import com.joptimizer.optimizers.OptimizationResponse;
import lombok.SneakyThrows;
import lombok.extern.java.Log;
import org.apache.commons.lang3.ArrayUtils;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

@Log

</passage>
<passage file_path=/src/test/java/joptimizer/Test2DimQP.java>
    public static void main(String[] args) {
        double[][] Q = {{2, 0}, {0, 2}};
        double[] c = {-4, -4};
        var objectiveFunction = new ConvexMultivariateRealFunction() {
            @Override
            public double value(DoubleMatrix1D dm) {
                var X=dm.toArray();
                return 0.5 * (X[0] * X[0] * Q[0][0] + X[1] * X[1] * Q[1][1]) + c[0] * X[0] + c[1] * X[1];
            }

            @Override
            public DoubleMatrix1D gradient(DoubleMatrix1D dm) {
                var X=dm.toArray();
                return DoubleFactory1D.dense.make(new double[]{2 * X[0] - 4, 2 * X[1] - 4});
            }

            @Override
            public DoubleMatrix2D hessian(DoubleMatrix1D X) {
                return DoubleFactory2D.dense.make(Q); //
            }

            @Override
            public int getDim() {
                return 2;
            }
        };

        var inequalities = new ConvexMultivariateRealFunction[1];
        var upperBoundConstraint = UpperBoundConstraint.builder().nDim(2).idxVariable(0).ub(1d).build();

</passage>
<passage file_path=/src/test/java/optimization_apache/TestSumOfThree.java>
    @Test
    public void givenCorrectGradient_thenCorrectOptimum() {
        MultivariateOptimizer optimizer =
                TestHelper.getConjugateGradientOptimizer(RELATIVE_THRESHOLD,ABSOLUTE_THRESHOLD);
        SumOfThree sumOfThree=new SumOfThree(PEN_COEFF,EPS);
        PointValuePair optimum = null;
        CpuTimer timer=new CpuTimer();
        int nofCalls = 1000;
        for (int i = 0; i < nofCalls; i++) {
            optimum = TestHelper.gradientOptimize(
                    optimizer,sumOfThree.getObjectiveFunction(),sumOfThree.getGradientFactory(),
                    initialGuess, NOF_EVAL_MAX);
        }

        System.out.println("time per optimize (ms) = " + (double) timer.absoluteProgress()/(double) nofCalls);
        TestHelper.printPointValuePair(optimum);

        TestHelper.printOptimizerStats(optimizer);
        Assert.assertArrayEquals(OPT_POINT, optimum.getPointRef(), DELTA);
    }


    @Test

</passage>
<passage file_path=/src/test/java/joptimizer/TestMatrixForms.java>
    @Test
    public void testQPWithQvector() throws Exception {
        log.info("testQP");

        // Objective function
        double pme = 1e-3;
        double[][] pMatrix = new double[][] {
                {pme, 0, 0 },
                { 0, pme, 0 },
                { 0, 0, pme}};
        double[] qVector= new double[]{-1, -2, -3};
        var objectiveFunction = new PDQuadraticMultivariateRealFunction(pMatrix, qVector, 0);

        //inequalities
        var inequalities = new ConvexMultivariateRealFunction[7];
        inequalities[0] = new LinearMultivariateRealFunction(new double[]{1, 0, 0}, -50);// x1 <= 50
        inequalities[1] = new LinearMultivariateRealFunction(new double[]{0, 1, 0}, -50);// x2 <= 50
        inequalities[2] = new LinearMultivariateRealFunction(new double[]{0, 0, 1}, -50);// x3 <= 50
        inequalities[3] = new LinearMultivariateRealFunction(new double[]{-1, 0, 0}, 0.0);// x1 > 0.0
        inequalities[4] = new LinearMultivariateRealFunction(new double[]{0, -1, 0}, 0.0);// x2 > 0.0
        inequalities[5] = new LinearMultivariateRealFunction(new double[]{0, 0, -1}, 0.0);// x3 > 0

</passage>
<passage file_path=/src/test/java/apach_linear_algebra/TestMatrixAndVector.java>
public class TestMatrixAndVector {


    private RealMatrix m;
    private RealMatrix n;


    @Before
    public void init() {
        double[][] matrixData = { {1d,2d,3d}, {2d,5d,3d}};
        m = MatrixUtils.createRealMatrix(matrixData);

        // One more with three rows, two columns, this time instantiating the
        // RealMatrix implementation class directly.
        double[][] matrixData2 = { {1d,2d}, {2d,5d}, {1d, 7d}};
        n = new Array2DRowRealMatrix(matrixData2);

    }

    @Test

</passage>
<passage file_path=/src/test/java/optimization_apache/TestSumOfThreeUsingAdapter.java>
package optimization_apache;

import optimization_apache.interfaces_adapter.AdapterInterface;
import optimization_apache.interfaces_adapter.OptimizeAdapter;
import optimization_apache.interfaces_adapter.OptimizationModelInterface;
import optimization_apache.models.SumOfThreeModel;
import org.apache.commons.math3.optim.PointValuePair;
import org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer;
import org.junit.Assert;
import org.junit.Test;

public class TestSumOfThreeUsingAdapter {

</passage>
<passage file_path=/src/main/java/optimization_apache/depot_charging/DepotModel.java>
    @Builder
    public DepotModel(double[] kList, double[] pMaxList, double[] socList, double pDepotMax, double socMax,
                      Double barrierWeight, Double barrierWeightQuad) {
        Preconditions.checkArgument(kList.length==pMaxList.length && kList.length==socList.length, "Non equal inputs");

        this.kList = kList;
        this.pMaxList = pMaxList;
        this.socList = socList;
        this.pDepotMax = pDepotMax;
        this.socMax = socMax;
        this.barrierWeightLin = DefaultIf.defaultIfNullDouble.apply(barrierWeight,BARRIER_WEIGHT);
        this.barrierWeightQuad= DefaultIf.defaultIfNullDouble.apply(barrierWeightQuad,BARRIER_WEIGHT);
        this.finiteDiffGradient=new FiniteDiffGradientCalculator(getObjectiveFunction(), EPS);
    }

    public ObjectiveFunction getObjectiveFunction() {
        return new ObjectiveFunction(point -> getObjective(point) + violations(point).barrier(barrierWeightLin,barrierWeightQuad));
    }

    private  double getObjective(double[] xList) {

</passage>
<passage file_path=/src/main/java/plotting/LinesInSameChart.java>
package plotting;

import org.knowm.xchart.SwingWrapper;
import org.knowm.xchart.XYChart;
import org.knowm.xchart.XYChartBuilder;
import org.knowm.xchart.XYSeries;
import org.knowm.xchart.style.XYStyler;
import org.knowm.xchart.style.markers.SeriesMarkers;

public class LinesInSameChart {

    public static void main(String[] args) {
        int nofLines = 4;
        XYChart chart = new XYChartBuilder().xAxisTitle("X").yAxisTitle("Y").width(600).height(400).build();
        XYStyler styler = chart.getStyler();
        styler.setYAxisMin(-10d);
        styler.setYAxisMax(10d);
        styler.setPlotGridLinesVisible(true);

        for (int i = 0; i < nofLines; i++) {
            XYSeries series = chart.addSeries("" + i, null, DataGenerator.getRandomWalk(200));
            series.setMarker(SeriesMarkers.NONE);
        }
        var sw= new SwingWrapper<>(chart).displayChart();
    }


}

</passage>
<passage file_path=/src/test/java/optimization_apache/TestBowlOptimizationNonLinearConjugateGradient.java>
public class TestBowlOptimizationNonLinearConjugateGradient {

    public static final double DELTA = 1.0e-1;
    public static final double EPSILON = 1e-10;
    public static final int NOF_EVAL_MAX = 100;
    public static final double RELATIVE_THRESHOLD = 1e-1;
    public static final double ABSOLUTE_THRESHOLD = 1e-2;
    double[] INITIAL_GUESS = {1.0, 1.0};

    @Test
    public void givenBowl_thenOrigoIsOptimim () {
        Bowl bowl=new Bowl();
        MultivariateOptimizer optimizer=TestHelper.getConjugateGradientOptimizer(RELATIVE_THRESHOLD, ABSOLUTE_THRESHOLD);
        PointValuePair optimum = TestHelper.gradientOptimize(
                optimizer,bowl.getObjectiveFunction(),bowl.getGradient(),
                INITIAL_GUESS, NOF_EVAL_MAX);

        TestHelper.printPointValuePair(optimum);
        doAsserts(optimum);
    }

    @Test

</passage>
<passage file_path=/src/main/java/plotting/TradingChartsExample.java>
public class TradingChartsExample {
    public static final int WIDTH = 400, HEIGHT = 200;
    public static final String X_TITLE = "Time (h)";
    public static final double[] X_DATA = {0.0, 4.0, 8.0, 12.0, 16.0, 20.0, 24.0};

    public static void main(String[] args) throws Exception {

        List<XYChart> inputCharts = new ArrayList<>();
        addElPriceChart(inputCharts);
        addPowerReservePriceChart(inputCharts);
        new SwingWrapper<>(inputCharts).displayChartMatrix();

        List<XYChart> socTrajCharts = new ArrayList<>();
        addOnlyDayAhead(socTrajCharts);
        addOnlyFreq(socTrajCharts);
        addBoth1(socTrajCharts);
        addBoth2(socTrajCharts);
        new SwingWrapper<>(socTrajCharts).displayChartMatrix();

    }

    private static void addBoth2(List<XYChart> socTrajCharts) {

</passage>
<passage file_path=/src/main/java/optimization_apache/interfaces_adapter/OptimizationModelInterface.java>
package optimization_apache.interfaces_adapter;

public interface OptimizationModelInterface {
    double getObjective(double[] xList);
    double getPenalty(double[] xList);
    double getEps();
}

</passage>
<passage file_path=/src/main/java/optimization_apache/models/CircleScalar.java>
public class CircleScalar {
    private ArrayList<Vector2D> points;

    public CircleScalar() {
        points  = new ArrayList<>();
    }

    public void addPoint(double px, double py) {
        points.add(new Vector2D(px, py));
    }

    public double getRadius(Vector2D center) {
        double r = 0;
        for (Vector2D point : points) {
            r += point.distance(center);
        }
        return r / points.size();
    }

    public ObjectiveFunction getObjectiveFunction() {
        return new ObjectiveFunction(params -> {
            Vector2D center = new Vector2D(params[0], params[1]);
            double radius = getRadius(center);
            double sum = 0;
            for (Vector2D point : points) {
                double di = point.distance(center) - radius;
                sum += di * di;
            }
            return sum;
        });
    }

    public ObjectiveFunctionGradient getObjectiveFunctionGradient() {

</passage>
<passage file_path=/src/test/java/optimization_apache/TestBarrierJOpt.java>
            inequalities[2] = new LinearMultivariateRealFunction(new double[] {	0, 0, -1 }, 0);

            OptimizationRequest or = new OptimizationRequest();
            or.setNotFeasibleInitialPoint(new double[] { -0.2, 1.0, 0.2 });
            or.setCheckKKTSolutionAccuracy(true);
            or.setF0(objectiveFunction);
            // equalities
            or.setA(new double[][] { { 1, 1, 1 } });
            or.setB(new double[] { 1 });
            //tolerances
            or.setTolerance(1.E-5);

            // optimization
            BarrierFunction bf = new LogarithmicBarrier(inequalities, 3);
            BarrierMethod opt = new BarrierMethod(bf);
            opt.setOptimizationRequest(or);
         /*   int returnCode = opt.optimize();

            if(returnCode==OptimizationResponse.FAILED){
                fail();
            }
            */

            OptimizationResponse response = opt.getOptimizationResponse();
            double[] expectedSol = {0.04632311555988555, 0.5086308460954377, 0.44504603834467693};

</passage>
<passage file_path=/src/test/java/joptimizer/TestMatrixForms.java>
        inequalities[5] = new LinearMultivariateRealFunction(new double[]{0, 0, -1}, 0.0);// x3 > 0
        inequalities[6] = new LinearMultivariateRealFunction(new double[]{1, 1, 1}, -120.0);// sum < 120


        //optimization problem
        var or = new OptimizationRequest();
        or.setF0(objectiveFunction);
        or.setInitialPoint(new double[]{1, 1, 1.1});
        or.setFi(inequalities);
//        or.setToleranceFeas(1.E-12);
//        or.setTolerance(1.E-12);

        //optimization
        var opt = new JOptimizer();
        opt.setOptimizationRequest(or);
        opt.optimize();


        var response = opt.getOptimizationResponse();
        double[] sol = response.getSolution();
        double value = objectiveFunction.value(new DenseDoubleMatrix1D(sol));
        log.info("sol   : " + ArrayUtils.toString(sol));
        log.info("value : " + value);
        assertEquals(2, sol[0], TOL);
        assertEquals(5., sol[1], TOL);
        assertEquals(5., sol[2], TOL);
//        assertEquals( -50,  value, TOL);

</passage>
<passage file_path=/src/test/java/joptimizer/TestSquaredBracketsModel.java>
    @SneakyThrows
    @Test
    void when() {
        OptimizationRequest or = new OptimizationRequest();
        or.setF0(objectiveFunction); // Set the objective function
        or.setInitialPoint(new double[]{0.4, 0.4,0.4}); // Optional: initial guess
        or.setToleranceFeas(1.E-1); // Tolerance on feasibility
        or.setTolerance(1.E-1); // Tolerance on optimization

        NewtonLEConstrainedFSP optimizer = new NewtonLEConstrainedFSP();  //todo fix hession

        //var bf=new BarrierFunction();
        // var optimizer = new com.joptimizer.optimizers.BarrierMethod();

        optimizer.setOptimizationRequest(or);
        optimizer.optimize();

        OptimizationResponse response = optimizer.getOptimizationResponse();
        double[] sol = response.getSolution();
        log.info("sol   : " + ArrayUtils.toString(sol));

    }


}

</passage>
<passage file_path=/src/main/java/plotting/TradingChartsExample.java>
    private static void addBoth2(List<XYChart> socTrajCharts) {
        XYChart chartSoCBoth2 = getChartWithYLabelAndMinMaxY("SoC (%)",Pair.create(0d,100d));
        addSeries(chartSoCBoth2, X_DATA, new double[]{50, 80, 80, 80, 30, 30, 50}, "Both markets 2");
        socTrajCharts.add(chartSoCBoth2);
    }

    private static void addBoth1(List<XYChart> socTrajCharts) {
        XYChart chartSoCBoth1 = getChartWithYLabelAndMinMaxY("SoC (%)",Pair.create(0d,100d));
        addSeries(chartSoCBoth1, X_DATA, new double[]{50, 70, 70, 70, 40, 40, 50}, "Both markets 1");
        socTrajCharts.add(chartSoCBoth1);
    }

    private static void addOnlyFreq(List<XYChart> socTrajCharts) {
        XYChart chartSoCFreq = getChartWithYLabelAndMinMaxY("SoC (%)",Pair.create(0d,100d));
        addSeries(chartSoCFreq, X_DATA, new double[]{50, 50, 50, 50, 50, 50, 50}, "Freq regulation market");
        socTrajCharts.add(chartSoCFreq);
    }

    private static void addOnlyDayAhead(List<XYChart> socTrajCharts) {

</passage>
<passage file_path=/src/test/java/joptimizer/TestMatrixForms.java>
    @Test
    public void testQP() throws Exception {
        log.info("testQP");

        // Objective function
        double[][] pMatrix = new double[][] {
                { 1, 0, 0 },
                { 0, 1, 0 },
                { 0, 0, 1 }};
        var objectiveFunction = new PDQuadraticMultivariateRealFunction(pMatrix, null, 0);

        //inequalities
        var inequalities = new ConvexMultivariateRealFunction[1];
        inequalities[0] = new LinearMultivariateRealFunction(new double[]{1, 0, 0}, 10);// x1 <= -10

        //optimization problem
        var or = new OptimizationRequest();
        or.setF0(objectiveFunction);
        or.setInitialPoint(new double[]{-11, 1, 1});
        or.setFi(inequalities);
//        or.setToleranceFeas(1.E-12);
//        or.setTolerance(1.E-12);

        //optimization
        var opt = new JOptimizer();
        opt.setOptimizationRequest(or);
        opt.optimize();


        var response = opt.getOptimizationResponse();
        double[] sol = response.getSolution();
        double value = objectiveFunction.value(new DenseDoubleMatrix1D(sol));

</passage>
<passage file_path=/src/test/java/optimization_apache/TestBarrierJOpt.java>
            inequalities[2] = new LinearMultivariateRealFunction(new double[] {	0, 0, -1 }, 0);

            OptimizationRequest or = new OptimizationRequest();
            or.setCheckKKTSolutionAccuracy(true);
            or.setCheckProgressConditions(true);
            or.setF0(objectiveFunction);
            or.setInitialPoint(new double[] { 0.6, 0.2, 0.2 });
            // equalities
            or.setA(new double[][] { { 1, 1, 1 } });
            or.setB(new double[] { 1 });
            //tolerances
            or.setTolerance(1.E-5);

            // optimization
            BarrierFunction bf = new LogarithmicBarrier(inequalities, 3);
            BarrierMethod opt = new BarrierMethod(bf);
            opt.setOptimizationRequest(or);

            opt.optimize();

            /*
            if(returnCode==OptimizationResponse.FAILED){
                fail();
            }*/

            OptimizationResponse response = opt.getOptimizationResponse();
            double[] expectedSol = {0.04632311555988555, 0.5086308460954377, 0.44504603834467693};

</passage>
<passage file_path=/src/test/java/apache_common/FilterTest.java>
package apache_common;

import org.apache.commons.math3.filter.*;
import org.apache.commons.math3.linear.Array2DRowRealMatrix;
import org.apache.commons.math3.linear.ArrayRealVector;
import org.apache.commons.math3.linear.RealMatrix;
import org.apache.commons.math3.linear.RealVector;
import org.apache.commons.math3.random.JDKRandomGenerator;

import java.util.random.RandomGenerator;

public class FilterTest {

</passage>
<passage file_path=/src/test/java/joptimizer/Test2DimQP.java>
@Log
public class Test2DimQP {
    public static final double TOL = 1e-5;

    @SneakyThrows
    public static void main(String[] args) {

</passage>
<passage file_path=/src/test/java/optimization_apache/TestConstrainedRosenbrock.java>
    @Test
    public void givenManyInitGuesses_thenCorrectOptimum() {
        ConstrainedRosenbrock sumOfThree = new ConstrainedRosenbrock(PEN_COEFF,EPS);
        MultivariateOptimizer optimizer = TestHelper.getConjugateGradientOptimizer(RELATIVE_THRESHOLD,ABSOLUTE_THRESHOLD);
        PointValuePair bestOptimum = new PointValuePair(INITIAL_GUESS,Double.MAX_VALUE);

        for (int i = 0; i <100 ; i++) {
            PointValuePair optimum = getResultsFromRandomInitPoint(optimizer, sumOfThree);
            bestOptimum = calcOptimum(bestOptimum, optimum);
        }

        TestHelper.printPointValuePair(bestOptimum);
        TestHelper.printOptimizerStats(optimizer);
        Assert.assertArrayEquals(OPT_POINT, bestOptimum.getPointRef(), DELTA);
    }

    private static PointValuePair calcOptimum(PointValuePair bestOptimum, PointValuePair optimum) {

</passage>
<passage file_path=/src/main/java/optimization_apache/models/SumOfThree.java>
    public ObjectiveFunctionGradient getGradientFactory() {
        return gradientFactory.getFiniteDiffGradient();
    }

}

</passage>
<passage file_path=/src/main/java/optimization_apache/models/CircleScalar.java>
    public ObjectiveFunctionGradient getObjectiveFunctionGradient() {
        return new ObjectiveFunctionGradient(params -> {
            Vector2D center = new Vector2D(params[0], params[1]);
            double radius = getRadius(center);
            // gradient of the sum of squared residuals
            double dJdX = 0;
            double dJdY = 0;
            for (Vector2D pk : points) {
                double dk = pk.distance(center);
                dJdX += (center.getX() - pk.getX()) * (dk - radius) / dk;
                dJdY += (center.getY() - pk.getY()) * (dk - radius) / dk;
            }
            dJdX *= 2;
            dJdY *= 2;

            return new double[] { dJdX, dJdY };
        });
    }
}

</passage>
<passage file_path=/src/main/java/guava/GuavaMultiSetForFreqOfElement.java>
public class GuavaMultiSetForFreqOfElement {

    public static void main(String[] args) {
        Multiset<Integer> multiset = HashMultiset.create(Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4, 4));
        for (Integer element : multiset.elementSet()) {
            System.out.println(element + ": " + multiset.count(element));
        }
        // Using Guava's Ordering utility to find the most frequent element
        Optional<Multiset.Entry<Integer>> maxEntry = multiset.entrySet().stream()
                .max(Ordering.natural().onResultOf(Multiset.Entry::getCount));

        if (maxEntry.isPresent()) {
            System.out.println("Most frequent number: " + maxEntry.get().getElement() +
                    " (Frequency: " + maxEntry.get().getCount() + ")");
        } else {
            System.out.println("No elements in Multiset.");
        }
    }
}

</passage>
<passage file_path=/src/test/java/optimization_apache/TestConstrainedRosenbrock.java>
package optimization_apache;

import common.RandUtils;
import optimization_apache.models.ConstrainedRosenbrock;
import org.apache.commons.math3.optim.PointValuePair;
import org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer;
import org.junit.Assert;
import org.junit.Test;

import java.util.Arrays;


/**
 * ConstrainedRosenbrock has multiple local minima
 */
public class TestConstrainedRosenbrock {

</passage>
<passage file_path=/src/test/java/joptimizer/TestJoptimizerOnChargeDepotModel.java>
package joptimizer;

import cern.colt.matrix.impl.DenseDoubleMatrix1D;
import com.joptimizer.exception.JOptimizerException;
import com.joptimizer.optimizers.*;
import lombok.SneakyThrows;
import lombok.extern.java.Log;
import org.apache.commons.lang3.ArrayUtils;
import org.jetbrains.annotations.NotNull;
import org.junit.Before;
import org.junit.Test;
import org.junit.jupiter.api.Assertions;

import java.util.Arrays;

@Log

</passage>
<passage file_path=/src/test/java/optimization_apache/TestBarrierJOpt.java>
        ConvexMultivariateRealFunction objectiveFunction = new ConvexMultivariateRealFunction() {

            @Override
            public double value(DoubleMatrix1D X) {
                double x = X.toArray()[0];
                double y = X.toArray()[1];
                return 100 * (2*x + y) - Math.log(x)- Math.log(y);
            }

            @Override
            public DoubleMatrix1D gradient(DoubleMatrix1D X) {
                double x = X.toArray()[0];
                double y = X.toArray()[1];
                return new DenseDoubleMatrix1D(new double[]{200-1./x, 100-1./y});
            }

            @Override
            public DoubleMatrix2D hessian(DoubleMatrix1D X) {
                double x = X.toArray()[0];
                double y = X.toArray()[1];
                return new DenseDoubleMatrix2D(new double[][]{{1./Math.pow(x,2), 0},{0,1./Math.pow(y,2)}});
            }

            @Override
            public int getDim() {
                return 2;
            }
        };

</passage>
<passage file_path=/src/test/java/optimization_apache/TestBowlOptimizationNonLinearConjugateGradient.java>
    @Test
    public void givenBowlFinitDiffGradient_thenOrigoIsOptimim () {
        Bowl bowl=new Bowl();
        MultivariateOptimizer optimizer=TestHelper.getConjugateGradientOptimizer(RELATIVE_THRESHOLD, ABSOLUTE_THRESHOLD);
        PointValuePair optimum = TestHelper.gradientOptimize(
                optimizer,bowl.getObjectiveFunction(),bowl.getFiniteDiffGradient(EPSILON),
                INITIAL_GUESS, NOF_EVAL_MAX);

        TestHelper.printPointValuePair(optimum);
        doAsserts(optimum);
    }

    private static void doAsserts(PointValuePair optimum) {
        Vector2D point = new Vector2D(optimum.getPointRef()[0], optimum.getPointRef()[1]);
        Assert.assertEquals(0, point.getX(), DELTA);
        Assert.assertEquals(0, point.getY(), DELTA);
    }

}

</passage>
<passage file_path=/src/main/java/optimization_apache/models/Bowl.java>
public class Bowl {

    public ObjectiveFunction getObjectiveFunction() {
        return new ObjectiveFunction(point -> {
            double a = point[0];
            double b = point[1];
            return a * a + b * b;
        });
    }

    public ObjectiveFunctionGradient getGradient() {
        return new ObjectiveFunctionGradient(point -> {
            double a = point[0];
            double b = point[1];
            return new double[]{  2 * a ,  2 * b  }; // Gradient: [2a, 2b]
        });
    }

    public ObjectiveFunctionGradient getFiniteDiffGradient(double eps) {
        FiniteDiffGradientCalculator finiteDiffGradient = new FiniteDiffGradientCalculator(getObjectiveFunction(), eps);
        return finiteDiffGradient.getFiniteDiffGradient();
    }

}

</passage>
<passage file_path=/src/test/java/apache_common/CombinatoricsUtilsTest.java>
package apache_common;

import org.apache.commons.math3.util.CombinatoricsUtils;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class CombinatoricsUtilsTest {

    @Test
    public void whenFactorial_thenCorrect() {
        assertEquals(6, CombinatoricsUtils.factorial(3));
    }

    /***
     * n over k
     * Example, 6 ways to choose 2 elements from {1,2,3,4}:  {1,2}, {1,3}  ..
     */

    @Test
    public void whenBinCoeff_thenCorrect() {
        assertEquals(6, CombinatoricsUtils.binomialCoefficient(4,2));
    }

}

</passage>
<passage file_path=/src/main/java/joptimizer/TwoDimQpModel.java>
package joptimizer;

public class TwoDimQpModel {
}

</passage>
<passage file_path=/src/main/java/guava/GuavaMultiSet.java>
    }
}

</passage>
<passage file_path=/src/test/java/joptimizer/TestJoptimizerOnChargeDepotModel.java>
    private OptimizationResponse getOptimizationResponse(double[] initialPoint) throws JOptimizerException {
        OptimizationRequest or = new OptimizationRequest();
        or.setMaxIteration(1_000);
        or.setF0(model.costFunction()); // Set the objective function
        or.setFi(model.constraints());
        or.setInitialPoint(initialPoint); // Optional: initial guess
        or.setToleranceFeas(1e-5); // Tolerance on feasibility
        or.setTolerance(1e1); // Tolerance on optimization

        var optimizer = new JOptimizer();
        optimizer.setOptimizationRequest(or);
        optimizer.optimize();
        return optimizer.getOptimizationResponse();
    }



}

</passage>
<passage file_path=/src/main/java/optimization_apache/depot_charging/DepotModel.java>
public class DepotModel {

    public static final double EPS = 1e-5;
    public static final double BARRIER_WEIGHT = 1e-1;
    public static final double SMALL_POWER = 1e-2;
    public static final double POWER_MIN = 1e-2;
    double[] kList;
    double[] pMaxList;
    double[] socList;
    double pDepotMax;
    double socMax;
    @Setter double barrierWeightLin;
    @Setter double barrierWeightQuad;

    final FiniteDiffGradientCalculator finiteDiffGradient;

    @Builder

</passage>
<passage file_path=/src/main/java/guava/SortListOfPairs.java>
package guava;

import com.google.common.collect.Ordering;
import org.apache.commons.math3.util.Pair;

import java.util.Arrays;
import java.util.Comparator;
import java.util.List;

public class SortListOfPairs {
    public static void main(String[] args) {
        List<Pair<Integer, Double>> pairs = Arrays.asList(
                new Pair<>(1, 9.0),
                new Pair<>(2, 4.5),
                new Pair<>(3, 7.2)
        );

        // Custom Ordering using the second element of the Pair (Double value)
        Ordering<Pair<Integer, Double>> orderByDouble = Ordering.from(Comparator.comparingDouble(Pair::getValue));

        // Sort the list
        List<Pair<Integer, Double>> sortedPairs = orderByDouble.sortedCopy(pairs);

        // Print the sorted list
        sortedPairs.forEach(pair -> System.out.println(pair.getKey() + ": " + pair.getValue()));
    }
}
</passage>
<passage file_path=/src/test/java/apache_common/MultidimensionalCounterTest.java>
package apache_common;

import org.apache.commons.math3.util.MultidimensionalCounter;
import org.junit.Assert;
import org.junit.Test;

/**
 * This utility will convert from indices in a multidimensional structure
 *  * to the corresponding index in a one-dimensional array.
 */
public class MultidimensionalCounterTest {

    @Test
    public void whenTwoDimensions_thenCorrect() {

        MultidimensionalCounter mdc=new MultidimensionalCounter(3,2);
        System.out.println("mdc.getCount(0,0) = " + mdc.getCount(0, 0));
        System.out.println("mdc.getCount(2,0) = " + mdc.getCount(2, 0));
        System.out.println("mdc.getDimension() = " + mdc.getDimension());

        Assert.assertEquals(2,mdc.getDimension());

    }
}

</passage>
<passage file_path=/src/test/java/apache_common/AnaysisTest.java>
public class AnaysisTest {

    public static final double DELTA = 0.01;

    @Test
    public void whenInterpolation_thenCorrect() {

        double[] xArr = { 0.0, 1.0, 2.0 };
        double[] yArr = { 0.0, 1.0, 2.0};
        UnivariateInterpolator interpolator = new LinearInterpolator();
        UnivariateFunction function = interpolator.interpolate(xArr, yArr);
        double interpolationX = 0.5;
        double interpolatedY = function.value(interpolationX);
        System.out.println("f(" + interpolationX + ") = " + interpolatedY);
        assertEquals(0.5,interpolatedY, DELTA);
    }

    @Test

</passage>
<passage file_path=/src/test/java/apache_common/AnaysisTest.java>
package apache_common;

import org.apache.commons.math3.analysis.UnivariateFunction;
import org.apache.commons.math3.analysis.interpolation.LinearInterpolator;
import org.apache.commons.math3.analysis.interpolation.SplineInterpolator;
import org.apache.commons.math3.analysis.interpolation.UnivariateInterpolator;
import org.apache.commons.math3.analysis.solvers.AllowedSolution;
import org.apache.commons.math3.analysis.solvers.BracketingNthOrderBrentSolver;
import org.apache.commons.math3.analysis.solvers.UnivariateSolver;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class AnaysisTest {

</passage>
<passage file_path=/src/main/java/plotting/ErrorBarChart.java>
package plotting;

import org.knowm.xchart.SwingWrapper;
import org.knowm.xchart.XYChart;
import org.knowm.xchart.XYChartBuilder;
import org.knowm.xchart.XYSeries;
import org.knowm.xchart.style.markers.SeriesMarkers;

import java.awt.*;
import java.util.ArrayList;
import java.util.List;

public class ErrorBarChart {

</passage>
<passage file_path=/src/test/java/optimization_apache/TestSumOfThree.java>
    @Test
    @Ignore("Bound does not work")
    public void givenLineFiniteDiffGradientBounds_thenZeroIsOptimum() {
        MultivariateOptimizer optimizer =
                TestHelper.getConjugateGradientOptimizer(RELATIVE_THRESHOLD,ABSOLUTE_THRESHOLD);
        SumOfThree sumOfThree=new SumOfThree(PEN_COEFF,EPS);
        double[] lowerBounds = {-1.0, -1.0,-1.0};
        double[] upperBounds = {10.0, 10.0,10.0};
        PointValuePair optimum =
                optimizer.optimize(new MaxEval(NOF_EVAL_MAX),
                        sumOfThree.getObjectiveFunction(),
                        sumOfThree.getGradientFactory(),
                        GoalType.MINIMIZE,
                        new SimpleBounds(lowerBounds, upperBounds),  //gives MathUnsupportedOperationException
                        new InitialGuess(initialGuess));
        TestHelper.printPointValuePair(optimum);
        TestHelper.printOptimizerStats(optimizer);

    }


}

</passage>
<passage file_path=/src/main/java/joptimizer/SquaredBracketsModel.java>
package joptimizer;

public class SquaredBracketsModel {

    // Method to calculate the value of the objective function
    public double calculateObjectiveValue(double[] x) {
        double x1 = x[0];
        double x2 = x[1];
        return Math.pow(x1 - 1, 2) + Math.pow(x2 - 2, 2);
    }

    // Method to calculate the gradient of the objective function
    public double[] calculateObjectiveGradient(double[] x) {
        double x1 = x[0];
        double x2 = x[1];
        double gradX1 = 2 * (x1 - 1);
        double gradX2 = 2 * (x2 - 2);
        return new double[]{gradX1, gradX2};
    }

}

</passage>
<passage file_path=/src/test/java/joptimizer/TestJoptimizerOnChargeDepotModel.java>
@Log
public class TestJoptimizerOnChargeDepotModel {
    public static final double Q = 1e-5;
    public static final int TOL = 10;
    ChargeDepotModel model;

    @SneakyThrows
    @Before
    public void init() {
        model = ChargeDepotModel.builder()
                .isCharging(true)
                .kList(new double[]{0.2, 0.6, 0.2})  //model handles sign logik
                .qList(new double[]{Q, Q, Q})
                .pMaxList(new double[]{1000, 1000, 1000})
                .pMinList(new double[]{0, 0, 0})
                .socList(new double[]{0.5, 0.5, 0.99}).socMax(0.98)
                .pDepotMax(1200)
                .build();
    }


    @SneakyThrows

</passage>
<passage file_path=/src/main/java/plotting/MultiPlotsOneRow.java>
    public static void main(String[] args) {
        // Create several XYSeries
        XYSeries series1 = new XYSeries("Series 1");
        series1.add(1, 1);
        series1.add(2, 4);
        series1.add(3, 3);

        XYSeries series2 = new XYSeries("Series 2");
        series2.add(1, 2);
        series2.add(2, 5);
        series2.add(3, 6);

        XYSeries series3 = new XYSeries("Series 3");
        series3.add(1, 5);
        series3.add(2, 3);
        series3.add(3, 7);

        // Create datasets and charts for each series
        JFrame frame = new JFrame("Multiple Line Charts");
        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        frame.setLayout(new FlowLayout(FlowLayout.LEFT));

        // Process each series
        XYSeries[] allSeries = {series1, series2, series3};
        for (XYSeries series : allSeries) {

</passage>
<passage file_path=/src/main/java/common/ListUtils.java>
    public static boolean isDoubleArraysEqual(double[] x, double[] y, double tol)
    {
        if (x.length!=y.length) {
            return false;
        }
        for (int i = 0; i < x.length; i += 1)
        {
            if (Math.abs((y[i] - x[i])) > tol)
            {
                return false;
            }
        }
        return true;
    }

    public static List<Double> getDiscountList(int len, double discountFactor) {
        List<Double> listDf = new ArrayList<>();
        double df = 1;
        for (int i = 0; i < len; i++) {
            listDf.add(df);
            df = df * discountFactor;
        }
        return listDf;
    }

    public static<T> List<T> merge(List<T> list1, List<T> list2)
    {
        List<T> list = new ArrayList<>(list1);
        list.addAll(list2);

        return list;
    }

    public static List<Double> arrayPrimitiveDoublesToList(double[] arr) {
        return DoubleStream.of(arr).boxed().collect(Collectors.toList());
    }

}

</passage>
<passage file_path=/src/main/java/common/MathUtils.java>
    public static boolean isInRange(int value, int min, int max) {
        return (value>=min && value<=max);
    }


    public static double setAsSmallIfZero(double value) {
        return (isZero(value)?Double.MIN_VALUE:value);
    }

    public static String getRoundedNumberAsString(Double value, int nofDigits)  {
        NumberFormat nf = NumberFormat.getNumberInstance(Locale.ENGLISH);  //ENGLISH => point
        nf.setMaximumFractionDigits(nofDigits);
        return nf.format(value);
    }

    public static double normalize(double x,double xMin,double xMax) {
        return (x-xMin)/(xMax-xMin);
    }


    public static boolean compareIntScalars(int s1,int s2, int delta)
    {
        return (Math.abs(s1-s2)<delta);
    }

    public static boolean compareDoubleScalars(double s1,double s2, double delta)
    {
        return (Math.abs(s1-s2)<delta);
    }

    public static boolean compareDoubleArrays(double arr1[],double arr2[], double delta)

</passage>
<passage file_path=/src/main/java/plotting/BarChartsBeside.java>
package plotting;

import org.knowm.xchart.CategoryChart;
import org.knowm.xchart.CategoryChartBuilder;
import org.knowm.xchart.SwingWrapper;
import org.knowm.xchart.style.Styler;
import java.util.List;

public class BarChartsBeside {

    public static final List<String> CATEGORIES = List.of("cost buy", "cost degr", "income sell", "rev");

    public static void main(String[] args) {
        CategoryChart chart = new CategoryChartBuilder()
                .width(500).height(300)
                .title("").xAxisTitle("Type").yAxisTitle("Euro")
                .theme(Styler.ChartTheme.GGPlot2).build();
        chart.addSeries("1",CATEGORIES, List.of(30,10,30,-10));
        chart.addSeries("2",CATEGORIES, List.of(30,10,50,10));
        new SwingWrapper<>(chart).displayChart();
    }

}

</passage>
<passage file_path=/src/main/java/plotting/BarChartOverlapped.java>
package plotting;

import org.knowm.xchart.CategoryChart;
import org.knowm.xchart.CategoryChartBuilder;
import org.knowm.xchart.Histogram;
import org.knowm.xchart.SwingWrapper;
import org.knowm.xchart.style.Styler;

public class BarChartOverlapped {

</passage>
<passage file_path=/src/test/java/optimization_apache/TestSumOfThreeUsingAdapter.java>
public class TestSumOfThreeUsingAdapter {

    public static final double DELTA = 1.0e-1;
    public static final int NOF_EVAL_MAX = 10_000;
    public static final double EPS = 1e-3;
    public static final double PEN_COEFF = 1e1;
    public static final double RELATIVE_THRESHOLD = EPS;
    public static final double ABSOLUTE_THRESHOLD = EPS;
    public static final double[] OPT_POINT = {0, 0, 1.0};

    double[] initialGuess = {0.5, 0.5, 0.5};


    @Test

</passage>
<passage file_path=/src/main/java/dynamic_programming_best_path/dynamic_programming.md>
# Problem

![node](pics/nodes.png)

# Graph representation

The graph data model uses the adjacency list representation. A node name points to a list wth <nodeName,cost> pairs.

Every node is looked up by two maps, its name is the key. For one of the maps the value is depth in tree. For the other map the value is a list with destination nodes and edge costs.

# Dynamic programming algorithm

V(np)=min longCost(nd)  

where

cost(nd)=shortCost(np,nd)+V(nd)
nd is in np.edges
np.depth=nd.depth-1

for (d=depthMax-1..minDepth) {

    all nodes with depth d: update V
}
</passage>
<passage file_path=/src/test/java/optimization_apache/TestSumOfThree.java>
    @Test
    public void givenNonCorrectGradient_thenWrongOptimum() {
        SumOfThree sumOfThree=new SumOfThree(PEN_COEFF,EPS);
        MultivariateOptimizer optimizer =
                TestHelper.getConjugateGradientOptimizer(RELATIVE_THRESHOLD,ABSOLUTE_THRESHOLD);
        PointValuePair optimum = TestHelper.gradientOptimize(
                optimizer,sumOfThree.getObjectiveFunction(),sumOfThree.getWrongGradient(),
                initialGuess, NOF_EVAL_MAX);

        TestHelper.printPointValuePair(optimum);
        TestHelper.printOptimizerStats(optimizer);
        Assert.assertFalse(Arrays.equals(OPT_POINT, optimum.getPointRef()));
    }


    @Test

</passage>
<passage file_path=/src/main/java/common/MathUtils.java>
    public static boolean compareDoubleArrays(double arr1[],double arr2[], double delta)
    {
        if (arr1.length != arr2.length)
            return false;

        for (int i = 0; i < arr1.length; i++) {

            if (Math.abs(arr1[i] - arr2[i])>delta)
                return false;
        }
        return true;
    }

    public static List<Double> accumulatedSum(List<Double> list) {
        // Use AtomicReference to hold the running total
        AtomicReference<Double> runningSum = new AtomicReference<>(0.0);
        return list.stream().map(numberInList -> runningSum.updateAndGet(sum -> sum + numberInList))
                .collect(Collectors.toList());
    }

}

</passage>
<passage file_path=/src/test/java/optimization_apache/TestDepotModel.java>
package optimization_apache;

import optimization_apache.depot_charging.DepotModel;
import optimization_apache.depot_charging.ViolationResults;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

public class TestDepotModel {

</passage>
<passage file_path=/src/main/java/optimization_apache/models/Bowl.java>
package optimization_apache.models;

import optimization_apache.helpers.FiniteDiffGradientCalculator;
import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction;
import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunctionGradient;

public class Bowl {

</passage>
<passage file_path=/src/test/java/optimization_apache/TestOneDimLine.java>
public class TestOneDimLine {

    public static final double DELTA = 1.0e-1;
    public static final int NOF_EVAL_MAX = 1000;
    public static final double RELATIVE_THRESHOLD = 1e-1;
    public static final double ABSOLUTE_THRESHOLD = 1e-2;
    double[] initialGuess = {1.0};

    @Test
    public void givenLine_thenZeroIsOptimum() {
        OneDimLine line=new OneDimLine();
        MultivariateOptimizer optimizer =
                TestHelper.getConjugateGradientOptimizer(RELATIVE_THRESHOLD,ABSOLUTE_THRESHOLD);
        PointValuePair optimum = TestHelper.gradientOptimize(
                optimizer,line.getObjectiveFunction(),line.getGradient(),
                initialGuess, NOF_EVAL_MAX);

        printAndAssert(optimum);
    }

    private static void printAndAssert(PointValuePair optimum) {
        System.out.println("optimum.getPointRef() = " + Arrays.toString(optimum.getPointRef()));
        double x=optimum.getPointRef()[0];
        System.out.println("x = " + x);
    }
}

</passage>
<passage file_path=/src/main/java/common/ListUtils.java>
    public static double dotProduct(List<Double> listA,List<Double> listB)  {
        return IntStream.range(0, Math.min(listA.size(), listB.size()))
                .mapToDouble(i -> listA.get(i) * listB.get(i))
                .sum();
    }

    public static List<Double> elementProduct(List<Double> listA,List<Double> listB)  {
        return IntStream.range(0, Math.min(listA.size(), listB.size()))
                .mapToObj(i -> listA.get(i) * listB.get(i))
                .collect(Collectors.toList());
    }

    public static List<Double> createListWithZeroElements(int len) {
        return createListWithEqualElementValues(len,0);
    }

    public static List<Double> createListWithEqualElementValues(int len, double value) {
        return new ArrayList<>(Collections.nCopies(len,value));
    }

    public static List<Double> generateSequenceDoubleStream(double start, double end, double step) {

</passage>
<passage file_path=/src/test/java/optimization_apache/TestOneDimLine.java>
package optimization_apache;

import optimization_apache.models.OneDimLine;
import org.apache.commons.math3.optim.PointValuePair;
import org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer;
import org.junit.Test;

import java.util.Arrays;

public class TestOneDimLine {

</passage>
<passage file_path=/src/test/java/dynamic_programming/TestDP.java>
package dynamic_programming;


import dynamic_programming_best_path.calculator.BellmanCalculator;
import dynamic_programming_best_path.calculator.FindMax;
import dynamic_programming_best_path.calculator.FindMin;
import dynamic_programming_best_path.calculator.Strategy;
import dynamic_programming_best_path.models.Edge;
import dynamic_programming_best_path.models.Node;
import dynamic_programming_best_path.models.NodeAbstract;
import dynamic_programming_best_path.repo.NodeRepo;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

public class TestDP {

</passage>
<passage file_path=/src/test/java/google_common/TestCartesian.java>
public class TestCartesian {


    @Test
    public void whenCalculatingCartesianProductOfSets_thenCorrect() {
        Set<Integer> first = ImmutableSet.of(1, 2);
        Set<Integer> second = ImmutableSet.of(30, 40);
        Set<Integer> third = ImmutableSet.of(500, 600);
        Set<Integer> fourth = ImmutableSet.of(7000, 8000);

        Set<List<Integer>> result =
                Sets.cartesianProduct(ImmutableList.of(first, second,third,fourth));

        for (List<Integer> list:result) {
            System.out.println("list = " + list);
        }

        Assertions.assertEquals(2*2*2*2,result.size());

    }

}

</passage>
<passage file_path=/src/main/java/plotting/SimpleLine.java>
    }


}

</passage>
<passage file_path=/src/main/java/guava/GuavaMultiSet.java>
public class GuavaMultiSet {

    public static void main(String[] args) {
        Multiset<Integer> multiset = HashMultiset.create();
        multiset.add(1, 5); // Adds the element 1 five times
        multiset.add(2);
        multiset.remove(1, 3); // Removes three occurrences of 1
        multiset.setCount(1, 2); // Set the count directly, overriding the current count

        int count1 = multiset.count(1); // Returns the number of occurrences of 1
        Set<Integer> elementSet = multiset.elementSet(); // Gets the unique elements
        for (Multiset.Entry<Integer> entry : multiset.entrySet()) {
            System.out.println(entry.getElement() + " - " + entry.getCount());
        }


        int totalSize = multiset.size(); // Total elements, including duplicates
        int uniqueSize = multiset.elementSet().size(); // Just the unique elements

        System.out.println("count1 = " + count1);
        System.out.println("elementSet = " + elementSet);
        System.out.println("totalSize = " + totalSize);
        System.out.println("uniqueSize = " + uniqueSize);

</passage>
<passage file_path=/src/main/java/joptimizer/ChargeDepotModel.java>
@Builder
public class ChargeDepotModel {
    public static final double POWER_SMALL = 1;

    @Builder.Default
    boolean isCharging=true;
    double[] kList;
    double[] qList;
    double[] pMaxList;
    double[] pMinList;
    double[] socList;
    double pDepotMax;
    double socMax;

    public ConvexMultivariateRealFunction costFunction() {

        double[][] pMatrix = new double[kList.length][kList.length];
        for (int i = 0; i < pMatrix.length && i < qList.length; i++) {
            pMatrix[i][i] = qList[i];
        }
       double[] kVector= DoubleStream.of(kList).map(x -> isCharging?-x:x).toArray();
       return new PDQuadraticMultivariateRealFunction(pMatrix, kVector, 0);
    }

    public ConvexMultivariateRealFunction[] constraints() {
        return  isCharging
                ? ArrayUtils.addAll(zeroPowerHighSoc(),ArrayUtils.addAll(bounds(),powerTotal()))
                : ArrayUtils.addAll(bounds(),powerTotal());

    }

    public ConvexMultivariateRealFunction[] bounds() {

</passage>
<passage file_path=/src/test/java/apach_linear_algebra/TestMatrixAndVector.java>
package apach_linear_algebra;

import org.apache.commons.math3.linear.*;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;


/**
 *
 * https://commons.apache.org/proper/commons-math/userguide/linear.html
 * math3 is newer and better than math2
 */

public class TestMatrixAndVector {

</passage>
<passage file_path=/src/main/java/guava/GuavaMultiSet.java>
        System.out.println("uniqueSize = " + uniqueSize);

        ImmutableMultiset<Integer> highestCountFirst = Multisets.copyHighestCountFirst(multiset);
        System.out.println("highestCountFirst = " + highestCountFirst);
        System.out.println("highest count = " + highestCountFirst.stream().findFirst().orElseThrow());

        Ordering<Multiset.Entry<Integer>> byCountOrdering = Ordering.natural().onResultOf(Multiset.Entry::getCount);
        Optional<Multiset.Entry<Integer>> maxEntry = multiset.entrySet().stream()
                .max(byCountOrdering);
        System.out.println("element highest count = " + maxEntry.orElseThrow().getElement());


    }

</passage>
<passage file_path=/src/main/java/optimization_apache/models/CircleScalar.java>
package optimization_apache.models;

import org.apache.commons.math3.geometry.euclidean.twod.Vector2D;
import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction;
import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunctionGradient;

import java.util.ArrayList;

public class CircleScalar {

</passage>
<passage file_path=/src/main/java/plotting/MultiPlotsOneRow.java>
    }

    @NotNull
    private static JFreeChart getChart(XYSeries series) {
        XYSeriesCollection dataset = new XYSeriesCollection();
        dataset.addSeries(series);
        return ChartFactory.createXYLineChart(
                series.getKey().toString(),  // Chart title
                "X",                         // X-Axis label
                "Y",                         // Y-Axis label
                dataset,                     // Dataset
                PlotOrientation.VERTICAL,
                true,                        // Show legend
                true,                        // Use tooltips
                false                        // Configure chart to generate URLs?
        );
    }

}

</passage>
<passage file_path=/src/main/java/common/ListUtils.java>
    public static List<Double> generateSequenceDoubleStream(double start, double end, double step) {
        return DoubleStream.iterate(start, d -> d <= end, d -> d + step)
                .boxed()
                .collect(Collectors.toList());
    }

    public static double[] toArray(List<Double> list) {
        return list.stream().mapToDouble(Number::doubleValue).toArray();
    }

    /**
     *  list = [10 10 10], df=0.5 => listDf=[1*df^0 1*df^1 1*df^2] => dotProduct(list,listDf)=10+5+2.5
     */
    public static double discountedSum(List<Double> list, double discountFactor) {
        List<Double> listDf = getDiscountList(list.size(), discountFactor);
        return dotProduct(list,listDf);
    }

    /**
     * 1d,10d,10d , df=0.5->  10d,5d,2.5d
     */

    public static List<Double> discountedElements(List<Double> list, double discountFactor) {
        List<Double> listDf = getDiscountList(list.size(), discountFactor);
        return elementProduct(list,listDf);
    }

    /**

</passage>
<passage file_path=/src/main/java/plotting/ErrorBarChart.java>
public class ErrorBarChart {

    public static void main(String[] args) {

        XYChart chart = getChart();
        new SwingWrapper<>(chart).displayChart();
    }


    public static XYChart getChart() {

</passage>
<passage file_path=/src/main/java/plotting/MultiPlotsOneRow.java>
public class MultiPlotsOneRow {

    public static final int WIDTH = 200;
    public static final int HEIGHT = 200;

    public static void main(String[] args) {

</passage>
<passage file_path=/src/test/java/optimization_apache/TestDepotModel.java>
public class TestDepotModel {

    public static final int BARRIER_WEIGHT = 1;
    public static final double TOL = 1e-4;
    DepotModel model;

    @Before
    public void init() {
        model= DepotModel.builder()
                .kList(new double[]{1,1,1})
                .pMaxList(new double[]{1,1,1})
                .socList(new double[]{1,1,1})
                .pDepotMax(1)
                .socMax(1)
                .build();
    }

    @Test
    public void whenXAllZero_thenFeasible() {
        double pen=model.violations(new double[]{0,0,0}).barrier(BARRIER_WEIGHT, 1);
        System.out.println("pen = " + pen);
        Assert.assertEquals(0,pen, TOL);
    }

    @Test
    public void whenXAllOne_thenNotFeasible() {
        ViolationResults violations = model.violations(new double[]{1, 1, 1});
        double pen= violations.barrier(BARRIER_WEIGHT, 1);
        System.out.println("violations = " + violations);
        Assert.assertNotEquals(0,pen, TOL);
    }

    @Test

</passage>
<passage file_path=/src/main/java/optimization_apache/depot_charging/DepotModel.java>
package optimization_apache.depot_charging;

import com.google.common.base.Preconditions;
import common.Conditionals;
import common.DefaultIf;
import common.ListUtils;
import common.MathUtils;
import lombok.Builder;
import lombok.Setter;
import optimization_apache.helpers.FiniteDiffGradientCalculator;
import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction;
import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunctionGradient;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.IntStream;

import static common.Conditionals.executeOneOfTwo;
import static common.ListUtils.arrayPrimitiveDoublesToList;
import static common.MathUtils.normalize;

public class DepotModel {

</passage>
<passage file_path=/src/test/java/optimization_apache/TestFiniteDiffGradientCalculator.java>
public class TestFiniteDiffGradientCalculator {


    public static final double TOL = 0.1;

    /***
     * https://www.cuemath.com/calculus/derivative-of-sin-x/
     */

    @Test
    public void whenDerSinus_thenCosinus() {
            MultivariateFunction mf= point -> Math.sin(point[0]);
            ObjectiveFunction of=new ObjectiveFunction(mf);
            FiniteDiffGradientCalculator diffGradientCalculator=new FiniteDiffGradientCalculator(of,1e-5);
            ObjectiveFunctionGradient gradient=diffGradientCalculator.getFiniteDiffGradient();
            double[] derSinPI=gradient.getObjectiveFunctionGradient().value(new double[]{Math.PI});
            Assertions.assertEquals(Math.cos(Math.PI),derSinPI[0], TOL);
        }

}

</passage>
<passage file_path=/src/test/java/apache_common/LinearTest.java>
package apache_common;

import org.apache.commons.math3.linear.*;
import org.junit.Test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

public class LinearTest {

    @Test
    public void whenSolvingEqSystem_thenCorrect() {
        RealMatrix coefficients =
                new Array2DRowRealMatrix(new double[][] { { 2, 3, -2 }, { -1, 7, 6 }, { 4, -3, -5 } },
                        false);
        DecompositionSolver solver = new LUDecomposition(coefficients).getSolver();

        RealVector constants = new ArrayRealVector(new double[] { 1, -2, 1 }, false);
        RealVector solution = solver.solve(constants);
        System.out.println("solution = " + solution);

        RealVector answer = new ArrayRealVector(new double[] {-0.3698630137, 0.1780821918,-0.602739726}, false);
        RealVector diff = answer.subtract(solution);
        System.out.println("diff = " + diff);
        assertTrue(diff.getL1Norm()<0.001);
    }
}

</passage>
<passage file_path=/src/main/java/guava/GuavaOrdering.java>
public class GuavaOrdering {
    public static void main(String args[]) {
        List<Integer> numbers = new ArrayList<>();

        numbers.add(5);
        numbers.add(2);
        numbers.add(15);
        numbers.add(51);
        numbers.add(53);
        numbers.add(35);
        numbers.add(45);
        numbers.add(32);
        numbers.add(43);
        numbers.add(16);

        Ordering<Integer> ordering = Ordering.natural();
        System.out.println("Input List: ");
        System.out.println(numbers);

        numbers.sort(ordering);
        System.out.println("Sorted List: ");
        System.out.println(numbers);

        System.out.println("======================");
        System.out.println("List is sorted: " + ordering.isOrdered(numbers));
        System.out.println("Minimum: " + ordering.min(numbers));
        System.out.println("Maximum: " + ordering.max(numbers));

        numbers.sort(ordering.reverse());
        System.out.println("Reverse: " + numbers);

        numbers.add(null);
        System.out.println("Null added to Sorted List: ");
        System.out.println(numbers);

</passage>
<passage file_path=/src/main/java/common/MathUtils.java>
package common;

import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.concurrent.atomic.AtomicReference;
import java.util.logging.Logger;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class MathUtils {

</passage>
<passage file_path=/src/main/java/joptimizer/ChargeDepotModel.java>
package joptimizer;

import com.joptimizer.functions.ConvexMultivariateRealFunction;
import com.joptimizer.functions.PDQuadraticMultivariateRealFunction;
import lombok.Builder;
import org.apache.commons.lang3.ArrayUtils;

import java.util.stream.DoubleStream;

@Builder

</passage>
<passage file_path=/src/test/java/optimization_apache/TestDepotModel.java>
    @Test
    public void largerXIsBetter() {
        double cost0 = model.getObjectiveFunction().getObjectiveFunction().value(new double[]{1, 1, 1});
        double cost1 = model.getObjectiveFunction().getObjectiveFunction().value(new double[]{0.1, 0.1, 0.1});

        Assert.assertTrue(cost0>cost1);
    }




}

</passage>
<passage file_path=/src/main/java/optimization_apache/models/ConstrainedRosenbrock.java>
    public ObjectiveFunctionGradient getFiniteDiffGradient() {
        return finiteDiffGradient.getFiniteDiffGradient();
    }

}

</passage>
<passage file_path=/src/test/java/common/TestIndexFinder.java>
package common;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

public class TestIndexFinder {

</passage>
<passage file_path=/src/main/java/guava/GuavaRange.java>
        for (double i = 0.0; i <= 1.0; i += 0.1) {
            rangeList.add(Math.round(i * 10) / 10.0); // Round to one decimal place to avoid floating-point precision issues
        }

        // Print the list
        System.out.println(rangeList);

    }

</passage>
<passage file_path=/pom.xml>
<groupId>org.example</groupId>
    <artifactId>JavaMath</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>RELEASE</version>
            <scope>compile</scope>
        </dependency>
        <dependency>
            <groupId>org.jetbrains</groupId>
            <artifactId>annotations</artifactId>
            <version>RELEASE</version>
            <scope>compile</scope>
        </dependency>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.12</version>
            <scope>test</scope>
        </dependency>
</passage>
<passage file_path=/src/main/java/guava/GuavaDoubles.java>
    private void testDoubles() {
        double[] doubleArray = {1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0};

        //convert array of primitives to array of objects
        List<Double> objectArray = Doubles.asList(doubleArray);
        System.out.println(objectArray.toString());

        //convert array of objects to array of primitives
        doubleArray = Doubles.toArray(objectArray);
        System.out.println(JOINED_STRING + Doubles.join(", ", doubleArray));

        List<Double> doubleList = List.of(3.5, 2.2, 5.1);
        double[] doubleArrayConv = Doubles.toArray(doubleList);
        String result = Doubles.join(", ", doubleArrayConv);
        System.out.println(JOINED_STRING + result);

        //check if element is present in the list of primitives or not
        System.out.println("5.0 is in list? " + Doubles.contains(doubleArray, 5.0f));

        //return the index of element
        System.out.println("5.0 position in list " + Doubles.indexOf(doubleArray, 5.0f));

        //Returns the minimum
        System.out.println("Min: " + Doubles.min(doubleArray));

</passage>
<passage file_path=/src/test/java/dynamic_programming/TestDP.java>
    @Test
    public void testSetup() {
        Assert.assertEquals(6,nodeRepo.nofItems());
        System.out.println(nodeRepo.get("1a"));
    }

    @Test
    public void testNodeRepoNodeDepth() {
        Assert.assertEquals(1,nodeRepo.findDepthMin());
        Assert.assertEquals(3,nodeRepo.findDepthMax());
    }

    @Test
    public void testDiscountFactor() {
        double df=0.5;
        BellmanCalculator bc=new BellmanCalculator(nodeRepo,new FindMin(),df);
        Assert.assertEquals(df,bc.calcDiscountFactorPowerDepth(1),0.1);
        Assert.assertEquals(df*df,bc.calcDiscountFactorPowerDepth(2),0.1);

    }

    @Test
    public void testFindBestOfEmptyList() {
        Strategy strategy=new FindMax();
        Assert.assertEquals(Strategy.BEST_IF_EMPTY_LIST,strategy.findBestInList(new ArrayList<>()),0.1);
    }

    @Test

</passage>
<passage file_path=/src/test/java/dynamic_programming/TestDP.java>
public class TestDP {

    final double DISCOUNT_FACTOR=1d;
    NodeRepo nodeRepo;
    BellmanCalculator bellmanCalculator;

    @Before
    public void setup() {
        nodeRepo=new NodeRepo();

        Node node1a=new Node("1a",1);
        node1a.setEdges(Arrays.asList(new Edge("2a",22.0),new Edge("2b",8.0),new Edge("2c",12.0)));
        nodeRepo.add(node1a);

        Node node2a=new Node("2a",2);
        node2a.setEdges(Arrays.asList(new Edge("3a",8.0),new Edge("3b",10.0)));
        nodeRepo.add(node2a);

        Node node2b=new Node("2b",2);
        node2b.setEdges(Arrays.asList(new Edge("3a",25.0),new Edge("3b",13.0)));
        nodeRepo.add(node2b);

        Node node2c=new Node("2c",2);
        node2c.setEdges(Arrays.asList(new Edge("3a",12.0),new Edge("3b",13.0)));
        nodeRepo.add(node2c);

        Node node3a=new Node("3a",3);
        node3a.setEdges(Collections.emptyList() );
        nodeRepo.add(node3a);

        Node node3b=new Node("3b",3);
        node3b.setEdges(Collections.emptyList() );
        nodeRepo.add(node3b);

        bellmanCalculator=new BellmanCalculator(nodeRepo,new FindMin(),DISCOUNT_FACTOR);

    }

    @Test

</passage>
<passage file_path=/src/main/java/plotting/ErrorBarChart.java>
    public static XYChart getChart() {

        // Create Chart
        XYChart chart = new XYChartBuilder().width(800).height(600).title("ScatterChart04").xAxisTitle("X").yAxisTitle("Y").build();

        // Customize Chart
        chart.getStyler().setDefaultSeriesRenderStyle(XYSeries.XYSeriesRenderStyle.Scatter);
        chart.getStyler().setChartTitleVisible(false);
        chart.getStyler().setLegendVisible(false);
        chart.getStyler().setAxisTitlesVisible(false);
        chart.getStyler().setXAxisDecimalPattern("0.00");

        // Series
        int size = 10;
        List<Double> xData = new ArrayList<>();
        List<Double> yData = new ArrayList<>();
        List<Double> errorBars = new ArrayList<>();
        for (int i = 0; i <= size; i++) {
            xData.add(((double) i) / 10);
            yData.add(10 * Math.exp(-i));
            errorBars.add(Math.random() + .3);
        }
        XYSeries series = chart.addSeries("10^(-x)", xData, yData, errorBars);
        series.setMarkerColor(Color.GRAY);
        series.setMarker(SeriesMarkers.SQUARE);

</passage>
<passage file_path=/src/test/java/apach_linear_algebra/TestMatrixAndVector.java>
    @Test
    public void given2DimMatrix_whenGettingRowAndColDimension_thenIsTwo() {
        // Now multiply m by n
        RealMatrix p = m.multiply(n);
        System.out.println(p.getRowDimension());    // 2
        System.out.println(p.getColumnDimension()); // 2

        Assert.assertEquals(2,p.getRowDimension());
        Assert.assertEquals(2,p.getColumnDimension());

        // Invert p, using LU decomposition
        RealMatrix inverse = MatrixUtils.inverse(p);

        System.out.println("inverse = " + inverse);

        Assert.assertEquals(2,inverse.getColumnDimension());
        Assert.assertEquals(2,inverse.getRowDimension());
    }

    @Test public void whenInverting_thenDim2() {
        RealMatrix p = m.multiply(n);
        RealMatrix inverse = MatrixUtils.inverse(p);
        System.out.println("inverse = " + inverse);
        Assert.assertEquals(2,inverse.getColumnDimension());
        Assert.assertEquals(2,inverse.getRowDimension());
    }

    @Test public void given2DimMatrixAndVector_whenMultipling_thenVector() {

</passage>
<passage file_path=/src/main/java/optimization_apache/models/OneDimLine.java>
    public ObjectiveFunctionGradient getGradient() {
        return new ObjectiveFunctionGradient(point -> {
            return new double[]{A}; // Gradient: [A]
        });
    }
}

</passage>
<passage file_path=/src/main/java/guava/GuavaDoubles.java>
        System.out.println("Min: " + Doubles.min(doubleArray));

        List<Double> numbers = Arrays.asList(5d, 3d, 9d, 1d, 4d);
        double min = Ordering.natural().min(numbers);
        System.out.println("min = " + min);

        List<Double> doubles = Arrays.asList(3.7, 4.1, 2.5, 10.2, 1.9);
        double minColl = Collections.min(doubles);
        System.out.println("Minimum value: " + minColl);

        //Returns the maximum
        System.out.println("Max: " + Doubles.max(doubleArray));

        System.out.println(JOINED_STRING + Doubles.join(", ", doubleArray));

        Doubles.sortDescending(doubleArray);
        System.out.println("Sorted array: " + Arrays.toString(doubleArray));

        int result1 = Doubles.compare(1, 2);
        int result2 = Doubles.compare(2, 0);
        System.out.println("Comparison result (array1 vs array2): " + result1); // 0, arrays are equal
        System.out.println("Comparison result (array1 vs array3): " + result2);

        double[] array1 = {1.0, 2.0};
        double[] array2 = {3.0, 4.0};

</passage>
<passage file_path=/src/main/java/plotting/SimpleLine.java>
public class SimpleLine {

    public static final String CHART_DIR = "src/main/java/xchart/saved_charts/", FILE_NAME = "Sample_Chart";

    public static void main(String[] args) throws Exception {
        double[] xData = new double[]{0.0, 1.0, 2.0};
        double[] yData = new double[]{2.0, 1.0, 0.0};
        XYChart chart = QuickChart.getChart("Sample Chart", "X", "Y", "y(x)", null, yData);
        new SwingWrapper<>(chart).displayChart();
        saveChart(chart);
    }

    private static void saveChart(XYChart chart) throws IOException {

</passage>
<passage file_path=/src/test/java/optimization_apache/TestFiniteDiffGradientCalculator.java>
package optimization_apache;

import optimization_apache.helpers.FiniteDiffGradientCalculator;
import org.apache.commons.math3.analysis.MultivariateFunction;
import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction;
import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunctionGradient;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

public class TestFiniteDiffGradientCalculator {

</passage>
<passage file_path=/src/main/java/optimization_apache/models/SumOfThreeModel.java>
package optimization_apache.models;

import common.ArrayUtil;
import common.ListUtils;
import optimization_apache.helpers.BarrierFunctions;
import optimization_apache.helpers.BoundConstraints;
import optimization_apache.interfaces_adapter.OptimizationModelInterface;
import java.util.ArrayList;
import java.util.List;

public class SumOfThreeModel implements OptimizationModelInterface {

</passage>
<passage file_path=/src/main/java/optimization_apache/helpers/FiniteDiffGradientCalculator.java>
    public ObjectiveFunctionGradient getFiniteDiffGradient() {
        return new ObjectiveFunctionGradient(point -> {
            double[] gradient = new double[point.length];
            double[] forwardPerturbedPoints = new double[point.length];
            double[] backwardPerturbedPoints = new double[point.length];
            ObjectiveFunction function=objectiveFunction;
            System.arraycopy(point, 0, forwardPerturbedPoints, 0, point.length);
            System.arraycopy(point, 0, backwardPerturbedPoints, 0, point.length);

            for (int i = 0; i < point.length; i++) {
                backwardPerturbedPoints[i] -= eps;
                forwardPerturbedPoints[i] += eps;
                double fBackward = function.getObjectiveFunction().value(backwardPerturbedPoints);
                double fCenter = function.getObjectiveFunction().value(point);
                double fForward = function.getObjectiveFunction().value(forwardPerturbedPoints);
                gradient[i] = ONE_DIV_TWO*(fForward - fCenter) / eps+ ONE_DIV_TWO *(fCenter-fBackward) / eps;
            }
            return gradient;
        });

</passage>
<passage file_path=/src/test/java/google_common/TestCartesian.java>
package google_common;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Sets;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.List;
import java.util.Set;

/**
<dependency>
<groupId>com.google.guava</groupId>
<artifactId>guava</artifactId>
<version>32.0.1-jre</version>
</dependency>
*/

public class TestCartesian {

</passage>
<passage file_path=/src/main/java/joptimizer/ChargeDepotModel.java>
    public ConvexMultivariateRealFunction[] zeroPowerHighSoc() {
        int nDim= pMaxList.length;

        var inequalities = new ConvexMultivariateRealFunction[nDim];
        for (int i = 0; i < nDim ; i++) {
            double ub=socList[i]<socMax ? pMaxList[i]: POWER_SMALL;
            inequalities[i] = UpperBoundConstraint.builder().nDim(nDim).idxVariable(i).ub(ub).build();
        }

        return inequalities;
    }


}

</passage>
<passage file_path=/src/main/java/common/ArrayUtil.java>
package common;

import java.util.Arrays;

public  class ArrayUtil {
   public static double sum(double[] array) {
       return Arrays.stream(array).sum();
   }
}

</passage>
<passage file_path=/src/main/java/guava/GuavaRange.java>
    private void testRange() {

        //create a range [a,b] = { x | a <= x <= b}
        Range<Integer> range1 = Range.closed(0, 9);
        System.out.print("[0,9] : ");
        printRange(range1);

        System.out.println("5 is present: " + range1.contains(5));
        System.out.println("(1,2,3) is present: " + range1.containsAll(Ints.asList(1, 2, 3)));
        System.out.println("Lower Bound: " + range1.lowerEndpoint());
        System.out.println("Upper Bound: " + range1.upperEndpoint());

        //create a range (a,b) = { x | a < x < b}
        Range<Integer> range2 = Range.open(0, 9);
        System.out.print("(0,9) : ");
        printRange(range2);

        //create a range (a,b] = { x | a < x <= b}
        Range<Integer> range3 = Range.openClosed(0, 9);
        System.out.print("(0,9] : ");
        printRange(range3);

        //create a range [a,b) = { x | a <= x < b}
        Range<Integer> range4 = Range.closedOpen(0, 9);
        System.out.print("[0,9) : ");
        printRange(range4);

        //create an open ended range (9, infinity

</passage>
<passage file_path=/src/main/java/optimization_apache/helpers/BoundConstraints.java>
    public static double[] getUpperBoundConstraintValues(double[] xList, double value) {
        return getUpperBoundConstraintValues(xList,getDoubles(getNofVars(xList), value));
    }

    private static double[] getDoubles(int nofVars, double value) {
        double[] lowerBounds=new double[nofVars];
        Arrays.fill(lowerBounds, value);
        return lowerBounds;
    }


    public static int getNofVars(double[] xList) {
        return xList.length;
    }

}

</passage>
<passage file_path=/src/main/java/guava/GuavaInt.java>
package guava;

import java.math.RoundingMode;
import com.google.common.math.IntMath;

public class GuavaInt {

    public static void main(String args[]) {
        GuavaInt tester = new GuavaInt();
        tester.testIntMath();
    }

    private void testIntMath() {

</passage>
<passage file_path=/src/main/java/guava/GuavaMultiSetForFreqOfElement.java>
package guava;

import com.google.common.collect.HashMultiset;
import com.google.common.collect.Multiset;
import com.google.common.collect.Ordering;

import java.util.Arrays;
import java.util.Optional;

public class GuavaMultiSetForFreqOfElement {

</passage>
<passage file_path=/src/test/java/apache_common/AnaysisTest.java>
    @Test
    public void whenSolver_thenCorrect() {
        UnivariateFunction function = (x) -> x;
        final double relativeAccuracy = 1.0e-12;
        final double absoluteAccuracy = 1.0e-8;
        final int    maxOrder         = 5;
        UnivariateSolver solver   = new BracketingNthOrderBrentSolver(relativeAccuracy, absoluteAccuracy, maxOrder);
        double c = solver.solve(100, function, -1.0, 5.0);
        System.out.println("c = " + c);

        assertEquals(0,c,DELTA);

    }
}

</passage>
<passage file_path=/src/main/java/dynamic_programming_best_path/calculator/FindMin.java>
package dynamic_programming_best_path.calculator;

import java.util.List;
import java.util.OptionalDouble;

public class FindMin implements Strategy{
    @Override
    public double findBestInList(List<Double> numbers) {
        logMessageIfEmptyList(numbers);
        OptionalDouble min = numbers.stream().mapToDouble(v -> v).min();
        return min.orElse(BEST_IF_EMPTY_LIST);
    }

    @Override
    public boolean isFirstBetterThanSecond(double num1, double num2) {
        return (num1<num2);
    }

    @Override
    public double badNumber() {
        return Double.MAX_VALUE;
    }
}

</passage>
<passage file_path=/src/main/java/optimization_apache/helpers/BoundConstraints.java>
public class BoundConstraints {

    public static double[] getLowerBoundConstraintValues(double[] xList, double[] lowerBounds) {
        int nofVars = getNofVars(xList);
        double[] constraintValues = new double[nofVars];
        for (int i = 0; i < nofVars; i++) {
            constraintValues[i] = lowerBounds[i] - xList[i];
        }
        return constraintValues;
    }

    public static double[] getUpperBoundConstraintValues(double[] xList, double[] upperBounds) {
        int nofVars = getNofVars(xList);
        double[] constraintValues = new double[nofVars];
        for (int i = 0; i < nofVars; i++) {
            constraintValues[i] = xList[i] - upperBounds[i];
        }
        return constraintValues;
    }

    public static double[] getLowerBoundConstraintValues(double[] xList, double value) {
        return getLowerBoundConstraintValues(xList,getDoubles(getNofVars(xList), value));
    }

    public static double[] getUpperBoundConstraintValues(double[] xList, double value) {

</passage>
<passage file_path=/src/main/java/guava/GuavaOrdering.java>
    }
}
</passage>
<passage file_path=/src/main/java/guava/GuavaRange.java>
        //create an open ended range (9, infinity
        Range<Integer> range5 = Range.greaterThan(9);
        System.out.println("(9,infinity) : ");
        System.out.println("Lower Bound: " + range5.lowerEndpoint());
        System.out.println("Upper Bound present: " + range5.hasUpperBound());

        Range<Integer> range6 = Range.closed(3, 5);
        printRange(range6);

        //check a subrange [3,5] in [0,9]
        System.out.println("[0,9] encloses [3,5]:" + range1.encloses(range6));

        Range<Integer> range7 = Range.closed(9, 20);
        printRange(range7);

        //check ranges to be connected
        System.out.println("[0,9] is connected [9,20]:" + range1.isConnected(range7));
        Range<Integer> range8 = Range.closed(5, 15);

        //intersection
        printRange(range1.intersection(range8));

        //span
        printRange(range1.span(range8));

        List<Double> rangeList = new ArrayList<>();
        for (double i = 0.0; i <= 1.0; i += 0.1) {

</passage>
<passage file_path=/src/main/java/common/RandUtils.java>
package common;

import java.util.List;

public class RandUtils<T> {

    public static String getRandomItemFromStringList(List<String> list) {
        return list.get(getRandomIntNumber(0,list.size()));
    }

    public  T getRandomItemFromList(List<T> list) {
        return list.get(getRandomIntNumber(0,list.size()));
    }

    public static int getRandomIntNumber(int minInclusive, int maxExclusive) {
        return (int) ((Math.random() * (maxExclusive - minInclusive)) + minInclusive);
    }

    public static double getRandomDouble(double minValue, double maxValue) {
        return minValue+Math.random()*(maxValue-minValue);
    }

}

</passage>
<passage file_path=/src/main/java/optimization_apache/helpers/BarrierFunctions.java>
    public  Function<Double,Double> setFunction(String type) {
        Map<Predicate<String>, Function<Double,Double>> functionTable= createFunctionTable(penCoeff);
        List<Function<Double,Double>> fcnList=functionTable.entrySet().stream()
                .filter(e -> e.getKey().test(type))
                .map(Map.Entry::getValue)
                .collect(Collectors.toList());
        throwIfMotivated(fcnList);
        return fcnList.get(0);
    }

    private static void throwIfMotivated(List<Function<Double, Double>> fcnList) {
        if (fcnList.size()>1) {
            throw  new RuntimeException("Multiple matching rules, nof ="+ fcnList.size());
        }

        if (fcnList.size()==0) {
            throw  new RuntimeException("No matching rule");
        }
    }


}

</passage>
<passage file_path=/src/main/java/dynamic_programming_best_path/repo/RepositoryInterface.java>
package dynamic_programming_best_path.repo;

import java.util.List;

public interface RepositoryInterface<T> {
    void add(T t);
    T get(String id);
    List<T> getAll();
    boolean exists(String id);
    void remove(String id);
    public void clearAll();
    int nofItems();
}

</passage>
<passage file_path=/src/main/java/dynamic_programming_best_path/calculator/FindMax.java>
package dynamic_programming_best_path.calculator;

import java.util.List;
import java.util.OptionalDouble;

public class FindMax implements Strategy {

    @Override
    public double findBestInList(List<Double> numbers) {
        logMessageIfEmptyList(numbers);
        OptionalDouble max = numbers.stream().mapToDouble(v -> v).max();
        return max.orElse(BEST_IF_EMPTY_LIST);
    }

    @Override
    public boolean isFirstBetterThanSecond(double num1, double num2) {
        return (num1>num2);
    }

    @Override
    public double badNumber() {
        return -Double.MAX_VALUE;
    }
}

</passage>
<passage file_path=/src/main/java/guava/GuavaInt.java>
        System.out.println("greatest common divisor(100,50): " + IntMath.gcd(100,50));

        System.out.println("modulus(100,50): " + IntMath.mod(100,50));

        System.out.println("factorial(5): " + IntMath.factorial(5));

        //https://en.wikipedia.org/wiki/Binomial_coefficient
        System.out.println("binomial(2,2) = " + IntMath.binomial(2, 2));
    }

</passage>
<passage file_path=/src/main/java/dynamic_programming_best_path/calculator/BellmanCalculator.java>
    private List<Double> findCostCandidatesForNode(Node np) {

        List<Double> costList = new ArrayList<>();

        if (np.getEdges().size() == 0) {
            logger.warning("No edges for node:" + np.getName());
            return costList;
        }

        for (Edge edge : np.getEdges()) {
            if (!nodeRepo.exists(edge.destinationNodeName)) {
                logger.warning("For node " + np.getName() + ", is the destination node not defined: " + edge.destinationNodeName);
            } else {
                double cost = calcLongCost(np, edge);
                costList.add(cost);
            }
        }
        return costList;
    }



    public double calcDiscountFactorPowerDepth(int depth) {
        return Math.pow(discountFactor, (depth - minDepth) + 1);
    }


    public List<NodeAbstract> findNodesOnOptimalPath(NodeAbstract startNode) {
        nodesOnOptPath = new ArrayList<>();
        addBestNodeAndFindNewBestNodeRecursive(startNode);
        return nodesOnOptPath;
    }

    public void addBestNodeAndFindNewBestNodeRecursive(NodeAbstract bestNode) {

</passage>
<passage file_path=/src/main/java/optimization_apache/models/SumOfThreeModel.java>
public class SumOfThreeModel implements OptimizationModelInterface {
    public static final double A0 = -0, A1 = -1, A2 = -2;
    public static final double LB = 0, UB = 1;
    public static final double SUM_MAX = 1;

    BarrierFunctions barrier;
    double eps;

    public SumOfThreeModel(double penCoeff, double eps) {
        this.barrier = new BarrierFunctions(penCoeff, "quad");
        this.eps=eps;
    }

    @Override
    public double getEps() {
        return eps;
    }

    @Override
     public double getObjective(double[] point) {
        return A0 * point[0] + A1 * point[1] + A2 * point[2];
    }

    /**
     * the constraint is violated (i.e., ci(vars) > 0)
     */

    @Override

</passage>
<passage file_path=/src/main/java/dynamic_programming_best_path/calculator/Strategy.java>
package dynamic_programming_best_path.calculator;

import java.util.List;
import java.util.logging.Logger;

public interface  Strategy {

    double BEST_IF_EMPTY_LIST=0d;
    Logger logger = Logger.getLogger(Strategy.class.getName());

    default void logMessageIfEmptyList(List<Double> numbers) {
        if (numbers.isEmpty()) {
            logger.warning("Finding min or max of empty list");
        }
    }

    double findBestInList(List<Double> numbers);
    boolean isFirstBetterThanSecond(double num1, double num2);
    double badNumber();
}

</passage>
<passage file_path=/src/main/java/guava/GuavaDoubles.java>
    }
}
</passage>
<passage file_path=/src/main/java/dynamic_programming_best_path/repo/NodeRepo.java>
public class NodeRepo implements  RepositoryInterface<Node>{

    HashMap<String, Node> nodes;

    public NodeRepo() {
        this.nodes = new HashMap<>();
    }

    @Override
    public void add(Node node) {
        nodes.put(node.getName(),node);
    }

    @Override
    public Node get(String id) {
        return nodes.get(id);
    }

    @Override
    public List<Node> getAll() {
        Collection<Node> values = nodes.values();
        return new ArrayList<>(values);
    }

    @Override
    public boolean exists(String id) {
        return nodes.containsKey(id);
    }

    @Override
    public void remove(String id) {
        nodes.remove(id);

    }

    @Override
    public void clearAll() {
        nodes.clear();
    }

    @Override
    public int nofItems() {
        return nodes.size();
    }

    public int findDepthMax() {
        List<Integer> depthList = getDepthList();
        return Collections.max(depthList);
    }

    public int findDepthMin() {
        List<Integer> depthList = getDepthList();
        return Collections.min(depthList);
    }

    public List<Node> findNodesAtDepth(Integer depth) {

</passage>
<passage file_path=/src/main/java/dynamic_programming_best_path/calculator/BellmanCalculator.java>
    public void setNodeValues() {

        for (int depth = nodeRepo.findDepthMax() - 1; depth >= nodeRepo.findDepthMin(); depth--) {
            List<Node> nodesAtDepth = nodeRepo.findNodesAtDepth(depth);
            for (Node np : nodesAtDepth) {
                List<Double> costs = findCostCandidatesForNode(np);
                np.setValue(strategy.findBestInList(costs));
            }
        }

    }

    private List<Double> findCostCandidatesForNode(Node np) {

</passage>
<passage file_path=/src/test/java/apache_common/NumberUtilsTest.java>
package apache_common;

import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.math.NumberUtils;
import org.apache.commons.math3.util.MultidimensionalCounter;
import org.junit.Test;

import java.util.Arrays;
import java.util.List;

import static org.junit.Assert.*;

public class NumberUtilsTest {

</passage>
<passage file_path=/src/main/java/optimization_apache/models/ConstrainedRosenbrock.java>
public class ConstrainedRosenbrock {

    public static final double LB = -1.5, UB = 1.5;
    private static final double[] LB_ARR = {LB, LB};
    private static final double[] UB_ARR = {UB, UB};

    static class Variables {
        public double[] xList;
    }

    BarrierFunctions barrier;
    FiniteDiffGradientCalculator finiteDiffGradient;

    public ConstrainedRosenbrock(double penCoeff, double eps) {
        this.barrier = new BarrierFunctions(penCoeff, "quad");
        this.finiteDiffGradient = new FiniteDiffGradientCalculator(getObjectiveFunction(), eps);
    }

    public ObjectiveFunction getObjectiveFunction() {
        return new ObjectiveFunction(point -> {
            Variables var = new Variables();
            var.xList = point;
            return getObjective(var) + getPenalty(var);
        });
    }

    private static double getObjective(Variables vars) {
        double x = vars.xList[0], y = vars.xList[1];
        return Math.pow(1 - x, 2) + 100 * Math.pow(y - Math.pow(x, 2), 2);
    }

    /**

</passage>
<passage file_path=/src/main/java/optimization_apache/models/SumOfThree.java>
package optimization_apache.models;

import common.ArrayUtil;
import common.ListUtils;
import optimization_apache.helpers.BarrierFunctions;
import optimization_apache.helpers.BoundConstraints;
import optimization_apache.helpers.FiniteDiffGradientCalculator;
import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction;
import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunctionGradient;

import java.util.ArrayList;
import java.util.List;

/**
 * sum=x0*A0+x1*A1+x2*A2
 * wrt
 * LB<xi<UB
 * x0+x1+x2<sumMax
 * <p>
 * The consequence is that the most effecting variable is as large as possible, the rest are zero
 * Hence opt point is {0, 0, 1.0};
 */

public class SumOfThree {

</passage>
<passage file_path=/src/main/java/dynamic_programming_best_path/calculator/BellmanCalculator.java>
public class BellmanCalculator {
    private static final Logger logger = Logger.getLogger(BellmanCalculator.class.getName());

    NodeRepo nodeRepo;
    Strategy strategy;
    double discountFactor;
    int maxDepth;
    int minDepth;
    List<NodeAbstract> nodesOnOptPath;

    public BellmanCalculator(NodeRepo nodeRepo,Strategy strategy, double discountFactor) {
        this.nodeRepo = nodeRepo;
        this.strategy=strategy;
        this.discountFactor = discountFactor;
        this.maxDepth = nodeRepo.findDepthMax();
        this.minDepth = nodeRepo.findDepthMin();
    }

    public List<NodeAbstract> getNodesOnOptPath() {
        return nodesOnOptPath;
    }

    public void setNodeValues() {

</passage>
<passage file_path=/src/main/java/optimization_apache/models/OneDimLine.java>
public class OneDimLine  {
    public static final double A = 1;
    public static final double B = 1;
    public static final double PEN_COEFF = Math.pow(10,6);

    static class Variables {
        public double x1;
    }

    public ObjectiveFunction getObjectiveFunction() {
        return new ObjectiveFunction(point -> {
            Variables var= new Variables();
            var.x1=point[0];
            return getObjective(var)+getPenalty(var);
        });
    }

    private static double getObjective(Variables vars) {
        return A * vars.x1 + B;
    }

    /**
     * the constraint is violated (i.e., ci(vars) > 0)
     */

    private static double getPenalty(Variables vars) {
        double constraintValue=0-vars.x1;
        return (MathUtils.isPos(constraintValue))
                ? PEN_COEFF *Math.pow(constraintValue,2)
                : 0;
    }

    public ObjectiveFunctionGradient getGradient() {

</passage>
<passage file_path=/src/main/java/optimization_apache/models/SumOfThree.java>
public class SumOfThree {
    public static final double A0 = -0, A1 = -1, A2 = -2;
    public static final double LB = 0, UB = 1;
    public static final double SUM_MAX = 1;

    public static class Variables {
        public double[] xList;
    }

    BarrierFunctions barrier;
    FiniteDiffGradientCalculator gradientFactory;

    public SumOfThree(double penCoeff, double eps) {
        this.barrier = new BarrierFunctions(penCoeff, "quad");
        this.gradientFactory = new FiniteDiffGradientCalculator(getObjectiveFunction(), eps);
    }

    public ObjectiveFunction getObjectiveFunction() {
        return new ObjectiveFunction(point -> {
            Variables var = new Variables();
            var.xList = point;
            return getObjective(var) + getPenalty(var);
        });
    }

    private static double getObjective(Variables vars) {
        return A0 * vars.xList[0] + A1 * vars.xList[1] + A2 * vars.xList[2];
    }

    /**
     * the constraint is violated (i.e., ci(vars) > 0)
     */

    private double getPenalty(Variables vars) {

</passage>
<passage file_path=/src/main/java/optimization_apache/helpers/BarrierFunctions.java>
@Log
public class BarrierFunctions {

    double penCoeff;
    Set<String> TYPES= Set.of("quad");

    Function<Double,Double> barrierFunction;

    public BarrierFunctions(double penCoeff,String type) {
        throwIfNotValidType(type);
        this.penCoeff = penCoeff;
        this.barrierFunction=setFunction(type);
    }

    private void throwIfNotValidType(String type) {
        if (!TYPES.contains(type)) {
            throw new IllegalArgumentException("Illegal type, allowed types = "+TYPES);
        }
    }

    private Map<Predicate<String>, Function<Double,Double>> createFunctionTable(double penCoeff) {
        Map<Predicate<String>, Function<Double,Double>> functionTable = new HashMap<>();
        Predicate<String> isQuad=(s) -> s.equals("quad");
        functionTable.put(isQuad,(cv) -> (cv >0)  ? penCoeff *Math.pow(cv,2): 0d);
        return functionTable;
    }


    public Double process(Double constraintValue) {
        return barrierFunction.apply(constraintValue);
    }
    public  Function<Double,Double> setFunction(String type) {

</passage>
<passage file_path=/src/main/java/optimization_apache/helpers/FiniteDiffGradientCalculator.java>
package optimization_apache.helpers;

import lombok.Setter;
import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction;
import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunctionGradient;

import java.util.Arrays;

/**
 * https://en.wikipedia.org/wiki/Finite_difference
 */

@Setter

</passage>
<passage file_path=/src/main/java/optimization_apache/helpers/BarrierFunctions.java>
package optimization_apache.helpers;

import lombok.extern.java.Log;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;

/**
 * Easy to extend thanks to functionTable
 */

@Log

</passage>
<passage file_path=/src/test/java/common/TestMathUtils.java>
package common;

import org.junit.Test;
import org.junit.jupiter.api.Assertions;

import java.util.List;

public class TestMathUtils {


    @Test
    public void whenAccumulatedSum_thenCorrect() {
        List<Double> accumulatedSum=MathUtils.accumulatedSum(List.of(1d,2d,3d));
        Assertions.assertEquals(List.of(1d,3d,6d),accumulatedSum);
    }

}

</passage>
<passage file_path=/src/main/java/joptimizer/LowerBoundConstraint.java>
@Builder
public class LowerBoundConstraint implements ConvexMultivariateRealFunction {

    @NonNull Integer nDim;
    @NonNull Integer idxVariable;
    @NonNull Double lb;

    @Builder.Default
    @Getter  int nIter =0;

    @Override
    public double value(DoubleMatrix1D dm) {
        nIter++;
        return -dm.toArray()[idxVariable]+ lb;  //xi>lb
    }

    @Override
    public DoubleMatrix1D gradient(DoubleMatrix1D dm) {
        double[] arr= new double[nDim];
        Arrays.fill(arr, 0);
        arr[idxVariable] = -1;
        return DoubleFactory1D.dense.make(arr);
    }

    @Override
    public DoubleMatrix2D hessian(DoubleMatrix1D dm) {
        return  new DenseDoubleMatrix2D(new double[nDim][nDim]);
    }

    @Override
    public int getDim() {
        return nDim;
    }
}

</passage>
<passage file_path=/src/test/java/apache_common/FractionTest.java>
package apache_common;

import org.apache.commons.math3.fraction.Fraction;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class FractionTest {

    @Test
    public void whenFraction1_4_thenCorrect() {
        Fraction frac1Div4=Fraction.getReducedFraction(1,4);
        System.out.println("frac1Div4 = " + frac1Div4);
    }


    @Test
    public void whenSummingFraction1_4_thenCorrect() {
        Fraction frac1Div4=Fraction.getReducedFraction(1,4);
        assertEquals(Fraction.getReducedFraction(1,2),frac1Div4.add(frac1Div4));
    }

}

</passage>
<passage file_path=/src/main/java/optimization_apache/models/ConstrainedRosenbrock.java>
package optimization_apache.models;

import common.ListUtils;
import optimization_apache.helpers.BarrierFunctions;
import optimization_apache.helpers.BoundConstraints;
import optimization_apache.helpers.FiniteDiffGradientCalculator;
import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction;
import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunctionGradient;

import java.util.ArrayList;
import java.util.List;


/***
 * https://en.wikipedia.org/wiki/Test_functions_for_optimization
 */

public class ConstrainedRosenbrock {

</passage>
<passage file_path=/src/main/java/dynamic_programming_best_path/repo/NodeRepo.java>
package dynamic_programming_best_path.repo;


import dynamic_programming_best_path.models.Node;
import org.jetbrains.annotations.NotNull;

import java.util.*;

public class NodeRepo implements  RepositoryInterface<Node>{

</passage>
<passage file_path=/src/main/java/guava/GuavaOrdering.java>
        System.out.println(numbers);

        numbers.sort(ordering.nullsFirst());
        System.out.println("Null first Sorted List: ");
        System.out.println(numbers);
        System.out.println("======================");


        List<String> names = new ArrayList<>();
        Ordering<String> orderingString = Ordering.natural();

        names.add("Ram");
        names.add("Shyam");
        names.add("Mohan");
        names.add("Sohan");
        names.add("Ramesh");
        names.add("Suresh");
        names.add("Naresh");
        names.add("Mahesh");
        names.add(null);
        names.add("Vikas");
        names.add("Deepak");

        System.out.println("Another List: ");
        System.out.println(names);

        names.sort(orderingString.nullsFirst().reverse());
        System.out.println("Null first then reverse sorted list: ");
        System.out.println(names);
    }

</passage>
<passage file_path=/src/main/java/dynamic_programming_best_path/repo/NodeRepo.java>
    public List<Node> findNodesAtDepth(Integer depth) {
        List<Node> allNodes=getAll();
        List<Node> nodesAtDepth=new ArrayList<>();

        for (Node node:allNodes) {
            if (node.getDepthIndex()==depth)
                nodesAtDepth.add(node);
        }

        return nodesAtDepth;
    }

    @NotNull
    private List<Integer> getDepthList() {
        List<Node> nodeList=getAll();
        List<Integer> depthList=new ArrayList<>();
        for (Node node:nodeList) {
            depthList.add(node.getDepthIndex());
        }
        return depthList;
    }

    public String toStringNodeValues() {

</passage>
<passage file_path=/src/main/java/plotting/SimpleLine.java>
package plotting;

import org.knowm.xchart.*;

import java.io.IOException;

import static org.knowm.xchart.BitmapEncoder.*;
import static org.knowm.xchart.VectorGraphicsEncoder.saveVectorGraphic;


public class SimpleLine {

</passage>
<passage file_path=/src/main/java/joptimizer/UpperBoundConstraint.java>
@Builder
public class UpperBoundConstraint implements ConvexMultivariateRealFunction {

    @NonNull Integer nDim;
    @NonNull Integer idxVariable;
    @NonNull Double ub;

    @Builder.Default
    @Getter  int nIter =0;

    @Override
    public double value(DoubleMatrix1D dm) {
        nIter++;
        return dm.toArray()[idxVariable]-ub;  //xi-ub<0
    }

    @Override
    public DoubleMatrix1D gradient(DoubleMatrix1D dm) {
        double[] arr= new double[nDim];
        Arrays.fill(arr, 0);
        arr[idxVariable] = 1;
        return DoubleFactory1D.dense.make(arr);
    }

    @Override
    public DoubleMatrix2D hessian(DoubleMatrix1D dm) {
        return  new DenseDoubleMatrix2D(new double[nDim][nDim]);
    }

    @Override
    public int getDim() {
        return nDim;
    }
}

</passage>
<passage file_path=/src/main/java/guava/GuavaInt.java>
    private void testIntMath() {
        try {
            System.out.println(IntMath.checkedAdd(Integer.MAX_VALUE, Integer.MAX_VALUE));

        } catch(ArithmeticException e) {
            System.out.println("Error: " + e.getMessage());
        }

        System.out.println(IntMath.divide(100, 5, RoundingMode.UNNECESSARY));
        try {
            //exception will be thrown as 100 is not completely divisible by 3
            // thus rounding is required, and RoundingMode is set as UNNESSARY
            System.out.println(IntMath.divide(100, 3, RoundingMode.UNNECESSARY));

        } catch(ArithmeticException e) {
            System.out.println("Error: " + e.getMessage());
        }

        System.out.println("Log2(2): " + IntMath.log2(2, RoundingMode.HALF_EVEN));

        System.out.println("Log10(10): " + IntMath.log10(10, RoundingMode.HALF_EVEN));

        System.out.println("sqrt(100): " + IntMath.sqrt(IntMath.pow(10,2), RoundingMode.HALF_EVEN));

        System.out.println("greatest common divisor(100,50): " + IntMath.gcd(100,50));

</passage>
<passage file_path=/src/main/java/dynamic_programming_best_path/models/NodeAbstract.java>
package dynamic_programming_best_path.models;

import lombok.Getter;
import lombok.ToString;

import java.util.List;

@Getter
abstract public class  NodeAbstract {

    @ToString.Exclude
    protected final double INIT_VALUE=0;

    protected  String name="";
    protected  int depthIndex=0;
    protected double value;
    protected List<Edge> edges;

    public abstract void setEdges(List<Edge> edges);
    public abstract void setValue(double value);
}

</passage>
<passage file_path=/src/main/java/optimization_apache/depot_charging/ViolationResults.java>
{

    public double barrier(double barrierWeightLin, double barrierWeightQuad) {
        return asList().stream().mapToDouble(v ->
                barrierWeightLin*Math.abs(v)+ barrierWeightQuad *Math.pow(v,2)).sum();
    }

    public List<Double> asList() {
        return  Stream.of(
                        Stream.of(depotPowerViolation), // Stream of the first single Double
                        slotPowerViolations.stream(), // Stream of the first list
                        noChargeWhenSoCIsHighViolations.stream(), // Stream of the second list
                        Stream.of(powerCirculationViolation) // Stream of the second single Double
                )
                .flatMap(DoubleStream -> DoubleStream) // Flatten the streams into one stream
                .collect(Collectors.toList());
    }

}

</passage>
<passage file_path=/src/test/java/optimization_apache/TestViolationResults.java>
package optimization_apache;

import optimization_apache.depot_charging.ViolationResults;
import org.junit.Assert;
import org.junit.Test;

import java.util.List;

public class TestViolationResults {

    @Test
    public void whenNoViolation_thenZeroBarrier() {
        var vr= ViolationResults.builder()
                .depotPowerViolation(0d)
                .slotPowerViolations(List.of(0d,0d))
                .noChargeWhenSoCIsHighViolations(List.of(0d,0d)).build();
        System.out.println("vr.asList() = " + vr.asList());

        Assert.assertEquals(0,vr.barrier(1, 1),1e-5);
    }

    @Test
    public void whenViolation_thenNonZeroBarrier() {
        var vr= ViolationResults.builder()
                .depotPowerViolation(-1d)
                .slotPowerViolations(List.of(1d,1d))
                .noChargeWhenSoCIsHighViolations(List.of(0d,0d)).build();

        Assert.assertNotEquals(0,vr.barrier(1, 1));
    }

}

</passage>
<passage file_path=/src/main/java/optimization_apache/models/SumOfThreeModel.java>
    @Override
    public double getPenalty(double[] point) {
        int nofVars = point.length;
        double[] lowerBoundsConstrValues = BoundConstraints.getLowerBoundConstraintValues(point, LB);
        double[] upperBoundsConstrValues = BoundConstraints.getUpperBoundConstraintValues(point, UB);
        List<Double> penalties = new ArrayList<>();
        for (int i = 0; i < nofVars; i++) {
            penalties.add(barrier.process(lowerBoundsConstrValues[i]));
            penalties.add(barrier.process(upperBoundsConstrValues[i]));
        }
        penalties.add(barrier.process(getSumOfVarsConstraintValue(point)));
        return ListUtils.sumList(penalties);
    }

    private static double getSumOfVarsConstraintValue(double[] point) {
        double sum = ArrayUtil.sum(point);
        return sum - SUM_MAX;
    }

}

</passage>
<passage file_path=/src/main/java/common/Conditionals.java>
package common;

public class Conditionals {

    /**
     * ifTrueMethod is executed if condition is true, else is ifFalseMethod executed
     * Handy to avoid ugly branching: if (condition) { trueMethod() } else { falseMethod() }
     * can be replaced by cleaner executeDependantOnCondition(condition,trueMethod,falseMethod)
     */
    public static void executeOneOfTwo(boolean condition, Runnable ifTrueMethod, Runnable ifFalseMethod) {
        (condition ? ifTrueMethod : ifFalseMethod).run();
    }

    /**
     * Following method is used if we want to run ifTrueMethod only if condition is true
     */
    public static void executeIfTrue(boolean condition, Runnable ifTrueMethod) {
        executeOneOfTwo(condition, ifTrueMethod, () -> {});
    }
}

</passage>
<passage file_path=/src/main/java/dynamic_programming_best_path/models/Node.java>
package dynamic_programming_best_path.models;

import lombok.Getter;
import lombok.ToString;

import java.util.List;

@Getter
@ToString
public class Node extends NodeAbstract {


    public Node(String name, int depthIndex) {
        this.name = name;
        this.depthIndex = depthIndex;
        this.value=this.INIT_VALUE;
    }

    public void setEdges(List<Edge> edges) {
        this.edges = edges;
    }

    public void setValue(double value) {
        this.value=value;
    }

}

</passage>
<passage file_path=/src/main/java/optimization_apache/depot_charging/ViolationResults.java>
package optimization_apache.depot_charging;

import lombok.Builder;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Builder
public record ViolationResults(
        Double depotPowerViolation,
        List<Double> slotPowerViolations,
        List<Double> noChargeWhenSoCIsHighViolations,
        Double powerCirculationViolation
)

{

</passage>
<passage file_path=/src/main/java/optimization_apache/models/OneDimLine.java>
package optimization_apache.models;
import common.MathUtils;
import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction;
import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunctionGradient;

public class OneDimLine  {

</passage>
<passage file_path=/src/main/java/joptimizer/SumConstraint.java>
@Builder
public class SumConstraint implements ConvexMultivariateRealFunction {

    @NonNull Integer nDim;
    @NonNull Boolean isSumMaxLimited;
    @NonNull Double limit;

    @Builder.Default
    @Getter
    int nIter = 0;

    @Override
    public double value(DoubleMatrix1D dm) {
        nIter++;
        return Boolean.TRUE.equals(isSumMaxLimited)
                ? Arrays.stream(dm.toArray()).sum() - limit
                : -Arrays.stream(dm.toArray()).sum() - limit;
    }

    @Override
    public DoubleMatrix1D gradient(DoubleMatrix1D dm) {
        double[] arr = new double[nDim];
        double gradElem=Boolean.TRUE.equals(isSumMaxLimited)?1:-1;
        Arrays.fill(arr, gradElem);
        return DoubleFactory1D.dense.make(arr);
    }

    @Override
    public DoubleMatrix2D hessian(DoubleMatrix1D dm) {
        return new DenseDoubleMatrix2D(new double[nDim][nDim]);
    }

    @Override
    public int getDim() {
        return nDim;
    }
}

</passage>
<passage file_path=/src/main/java/joptimizer/LowerBoundConstraint.java>
package joptimizer;

import cern.colt.matrix.DoubleFactory1D;
import cern.colt.matrix.DoubleMatrix1D;
import cern.colt.matrix.DoubleMatrix2D;
import cern.colt.matrix.impl.DenseDoubleMatrix2D;
import com.joptimizer.functions.ConvexMultivariateRealFunction;
import lombok.Builder;
import lombok.Getter;
import lombok.NonNull;

import java.util.Arrays;

@Builder

</passage>
<passage file_path=/src/main/java/joptimizer/UpperBoundConstraint.java>
package joptimizer;

import cern.colt.matrix.DoubleFactory1D;
import cern.colt.matrix.DoubleMatrix1D;
import cern.colt.matrix.DoubleMatrix2D;
import cern.colt.matrix.impl.DenseDoubleMatrix2D;
import com.joptimizer.functions.ConvexMultivariateRealFunction;
import lombok.Builder;
import lombok.Getter;
import lombok.NonNull;

import java.util.Arrays;

@Builder

</passage>
<passage file_path=/src/test/java/apache_common/ArithemticUtilsTest.java>
package apache_common;

import org.apache.commons.math3.util.ArithmeticUtils;
import org.junit.Assert;
import org.junit.Test;


public class ArithemticUtilsTest {

    @Test
    public void whenAddaAndCheck_thenCorrect() {
        Assert.assertEquals(2000, ArithmeticUtils.addAndCheck(1000,1000));
    }

    @Test
    public void whenMulAndCheck_thenCorrect() {
        Assert.assertEquals(1000_000, ArithmeticUtils.mulAndCheck(1000,1000));
    }

    @Test
    public void whenGcd_thenCorrect() {
        int gcd = ArithmeticUtils.gcd(1000, 100);  //greatest common divisor
        System.out.println("gcd = " + gcd);
        Assert.assertEquals(100, gcd);
    }

    @Test
    public void whenLcm_thenCorrect() {
        int lcm = ArithmeticUtils.lcm(4, 6);  //least common multiple of the absolute value of two numbers
        System.out.println("lcm = " + lcm);
        Assert.assertEquals(12, lcm);


    }


}

</passage>
<passage file_path=/src/main/java/dynamic_programming_best_path/models/Edge.java>
package dynamic_programming_best_path.models;



public class Edge {
    public String destinationNodeName;
    public Double cost;

    public Edge(String destinationNodeName, Double cost) {
        this.destinationNodeName = destinationNodeName;
        this.cost = cost;
    }

    @Override
    public String toString() {
       return "("+ destinationNodeName+", "+ cost+")";

    }

}

</passage>
<passage file_path=/src/main/java/joptimizer/SumConstraint.java>
package joptimizer;

import cern.colt.matrix.DoubleFactory1D;
import cern.colt.matrix.DoubleMatrix1D;
import cern.colt.matrix.DoubleMatrix2D;
import cern.colt.matrix.impl.DenseDoubleMatrix2D;
import com.joptimizer.functions.ConvexMultivariateRealFunction;
import lombok.Builder;
import lombok.Getter;
import lombok.NonNull;

import java.util.Arrays;

@Builder

</passage>
<passage file_path=/src/test/java/apache_common/NumberUtilsTest.java>
public class NumberUtilsTest {

    public static final double DELTA_DOUBLE = 0.01;

    @Test
    public void whenNotDigits_thenCorrect() {
        assertFalse(NumberUtils.isDigits("23g"));
        assertFalse(NumberUtils.isDigits("23.22"));
    }

    @Test
    public void whenDigits_thenCorrect() {
        assertTrue(NumberUtils.isDigits("22"));
    }


    @Test
    public void whenCompare_thenCorrect() {
        assertEquals(0,NumberUtils.compare(22,22));
        assertEquals(-1,NumberUtils.compare(21,22));
        assertEquals(1,NumberUtils.compare(23,22));
     //   assertEquals(1,NumberUtils.compare(23.22,22.3));  //not double
    }


    @Test
    public void whenMax_thenCorrect() {
        List<Double> doubleList = Arrays.asList(10d, 6d, 12d, 90d, 34d);
        Double[] array = doubleList.toArray(new Double[0]);
        double[] doubleArray = ArrayUtils.toPrimitive(array);
        assertEquals(90,NumberUtils.max(doubleArray), DELTA_DOUBLE);
    }


    @Test

</passage>
<passage file_path=/src/main/java/guava/GuavaBoolean.java>
    private void testBooleans() {
        boolean[] booleanArray = {true,true,false,true,true,false,false};

        //convert array of primitives to array of objects
        List<Boolean> objectArray = Booleans.asList(booleanArray);
        System.out.println(objectArray.toString());

        //convert array of objects to array of primitives
        booleanArray = Booleans.toArray(objectArray);
        System.out.print("[ ");

        for(int i = 0; i< booleanArray.length ; i++) {
            System.out.print(booleanArray[i] + " ");
        }

        System.out.println("]");

        //check if element is present in the list of primitives or not
        System.out.println("true is in list? " + Booleans.contains(booleanArray, true));

        //return the first index of element
        System.out.println("true position in list " + Booleans.indexOf(booleanArray, true));

        //Returns the count of true values
        System.out.println("true occured: " + Booleans.countTrue(booleanArray));

        //Returns the comparisons

</passage>
<passage file_path=/src/test/java/apache_common/NumberUtilsTest.java>
    @Test
    public void whenToDouble_thenCorrect() {
        assertEquals(22d,NumberUtils.toDouble("22"),DELTA_DOUBLE);
    }

    @Test
    public void whenToDoubleDefault_thenCorrect() {
        assertEquals(22d,NumberUtils.toDouble("22d",22),DELTA_DOUBLE);


    }

}

</passage>
<passage file_path=/src/main/java/common/DefaultIf.java>
public class DefaultIf {

   public static BiFunction<Double,Double,Double> defaultIfNull =(in, def) -> Objects.isNull(in) ? def:in;
   public static BiFunction<Integer,Integer,Integer> defaultIfNullInteger=(v, d) -> Objects.isNull(v)?d:v;
   public static BiFunction<Double,Double,Double> defaultIfNullDouble=(v, d) -> Objects.isNull(v)?d:v;
   public static BiFunction<Object,Object,Object> defaultIfNullObject=(v, d) -> Objects.isNull(v)?d:v;


   public static BiFunction<List<Double>,List<Double>,List<Double>> defListIfNull=(l, dl) -> Objects.isNull(l)?dl:l;
   public static Function<List<Double>,List<Double>> emptyListIfNull=(l) -> defListIfNull.apply(l,new ArrayList<>());

   public static final TriFunction<Boolean,Object,Object,Object> secIfFalse =(cond, ifTrue, ifFalse) ->
           Boolean.TRUE.equals(cond) ? ifTrue:ifFalse;

   public static final TriFunction<Boolean,Double,Double,Double> secDoubleIfFalse =(cond, ifTrue, ifFalse) ->
           Boolean.TRUE.equals(cond) ? ifTrue:ifFalse;


}

</passage>
<passage file_path=/src/main/java/guava/GuavaBoolean.java>
        //Returns the comparisons
        System.out.println("false Vs true: " + Booleans.compare(false, true));
        System.out.println("false Vs false: " + Booleans.compare(false, false));
        System.out.println("true Vs false: " + Booleans.compare(true, false));
        System.out.println("true Vs true: " + Booleans.compare(true, true));

        boolean[] finalBooleanArray = booleanArray;
        List<Integer> trueIndices = IntStream.range(0, booleanArray.length)
                .filter(i -> finalBooleanArray[i]).boxed().toList();
        System.out.println("trueIndices = " + trueIndices);

    }

</passage>
<passage file_path=/src/main/java/dynamic_programming_best_path/models/NullNode.java>
package dynamic_programming_best_path.models;

import java.util.List;

public class NullNode extends NodeAbstract {

    public NullNode() {
    }

    @Override
    public void setEdges(List<Edge> edges) {
    }

    @Override
    public void setValue(double value) {

    }
}

</passage>
<passage file_path=/src/main/java/common/CpuTimer.java>
package common;

import lombok.Getter;

import java.util.logging.Logger;

@Getter
public class CpuTimer {

    static final Logger logger = Logger.getLogger(CpuTimer.class.getName());
    long startTimeMillis;  //starting time, long <=> minimum value of 0
    protected long timeBudgetMillis;

    long absoluteProgress;
    float relativeProgress;


    public CpuTimer() {
        this(Long.MAX_VALUE);
    }

    public static CpuTimer newTimer(long timeBudgetMillis) {
        return new CpuTimer(timeBudgetMillis);

    }

    public CpuTimer(long timeBudgetMillis) {
        this.timeBudgetMillis = timeBudgetMillis;
        reset();
    }

    public void reset() {
        startTimeMillis = System.currentTimeMillis();
    }

    public void stop() {
        absoluteProgress=absoluteProgress();
        relativeProgress=relativeProgress();
    }

    public boolean isTimeExceeded() {
        return System.currentTimeMillis() > startTimeMillis + timeBudgetMillis;
    }

    public float relativeProgress() {
        return absoluteProgress()/ (float) timeBudgetMillis;
    }

    public long absoluteProgress() {

</passage>
<passage file_path=/src/main/java/guava/GuavaBoolean.java>
public class GuavaBoolean {
    public static void main(String args[]) {
        GuavaBoolean tester = new GuavaBoolean();
        tester.testBooleans();
    }

    private void testBooleans() {

</passage>
<passage file_path=/src/main/java/optimization_apache/helpers/BoundConstraints.java>
package optimization_apache.helpers;

import java.util.Arrays;

/**
 *   x>=LB =>  cv=LB-x;  violation <=> cv>0
 *   x<=UB =>  cv=x-UB;  violation <=> cv>0
 *
 */


public class BoundConstraints {

</passage>
<passage file_path=/src/main/java/common/CpuTimer.java>
    public long absoluteProgress() {
        return  (System.currentTimeMillis() - startTimeMillis);
    }

    public String toString() {
        return "timeBudgetMillis = "+timeBudgetMillis+", relativeProgress = "+relativeProgress;
    }

}

</passage>
<passage file_path=/src/main/java/common/DefaultIf.java>
package common;

import org.apache.commons.lang3.function.TriFunction;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.function.BiFunction;
import java.util.function.Function;

public class DefaultIf {

</passage>
